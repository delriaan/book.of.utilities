% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/miscellaneous.R
\name{call.recursion}
\alias{call.recursion}
\title{Execute a Function as Recursively}
\usage{
call.recursion(x, fun, test, nxt, max.iter = 1, cur.iter = 0, simplify = TRUE)
}
\arguments{
\item{x}{The input object}

\item{fun}{A function that operates on \code{x} and produces output}

\item{test}{A single-argument function returning a single Boolean: \code{FALSE} stops iteration}

\item{nxt}{A function that operates on the current output of \code{fun(x)} to send to the \emph{next} iterative call to \code{fun()}}

\item{max.iter}{(integer) The maximum number of iterations}

\item{cur.iter}{(integer) The current iteration index}

\item{simplify}{(logical) Should only the last value be returned (\code{TRUE}) or intermediate values as well (\code{FALSE})?}
}
\description{
\code{call.recursion} Executes a recursive calls to \code{fun} based on the output of \code{test} up to \code{max.iter} times
}
\examples{
book.of.utilities::call.recursion(
x = sample(1000, size = 100)
, fun = \(x){ abs(x - mean(x, na.rm = TRUE)) }
, test = \(x){
		if (length(unique(x)) == 1 || is.na(sd(x))){
			FALSE
		} else {
			i <- abs(x - mean(x, na.rm = TRUE))/sd(x);
			mean(i > 3) <= 0.7
		}
	}
, nxt = \(x){ sample(x, size = length(x)- 1, prob = runif(n = length(x), min = 0.1, max = 0.9)) }
, max.iter = 1000
, simplify = !FALSE
)

}
