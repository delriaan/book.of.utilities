purrr::reduce(rbind)
} else {
# Atomic input
sub_fn(vector, ...)
}
if (!rlang::is_empty(simplify_with)){
apply(.out, 1, simplify_with)
} else {
provideDimnames(.out, base = list(NULL, names(vpattern)))
}
vlogical(
vector = data.table::data.table(t(sapply(1:20, function(i){ c(a = sample(LETTERS, 1), b = sample(letters, 1)) })))
, vpattern = c(sample(LETTERS, 5), sample(letters, 5))
, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
, simplify_with = eval
, ignore.case = TRUE
)
vlogical(
vector = data.table::data.table(t(sapply(1:20, function(i){ c(a = sample(LETTERS, 1), b = sample(letters, 1)) })))
, vpattern = c(sample(LETTERS, 5), sample(letters, 5))
, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
, simplify_with = eval
, ignore.case = TRUE
)
data.table::data.table(t(sapply(1:20, function(i){ c(a = sample(LETTERS, 1), b = sample(letters, 1)) })))
data.table::data.table(t(sapply(1:20, function(i){ c(a = sample(LETTERS, 1), b = sample(letters, 1)) }))) |> outer(LETTERS, like)
outer(data.table::data.table(t(sapply(1:20, function(i){ c(a = sample(LETTERS, 1), b = sample(letters, 1)) }))), LETTERS, like)
outer(data.table::data.table(t(sapply(1:20, function(i){ c(a = sample(LETTERS, 1), b = sample(letters, 1)) }))), LETTERS, FUN = like)
outer(data.table::data.table(t(sapply(1:20, function(i){ c(a = sample(LETTERS, 1), b = sample(letters, 1)) }))), LETTERS, FUN = data.table::like)
outer(letters, sample(letters, 10), \(x, y) grepl(y, x))
outer(letters, sample(letters, 10), \(x, y) sapply(y, grepl, x))
outer(letters, sample(letters, 10), \(x, y) list(y, grepl, x))
lapply(letters, \(v){ p <- sample(letters, 10); sapply(p, grepl(v)) })
lapply(letters, \(v){ p <- sample(letters, 10); sapply(p, grepl, v) })
p <- sample(letters, 10); lapply(letters, \(v){ sapply(p, grepl, v) })
p <- sample(letters, 10); lapply(letters, \(v){ sapply(p, grepl, v) }) |> reduce(rbind)
p <- sample(letters, 10); lapply(letters, \(v){ sapply(p, grepl, v) }) |> purrr::reduce(rbind)
p <- sample(letters, 10); lapply(letters, stringi::stri_detect_regex, p) |> purrr::reduce(rbind)
p <- sample(letters, 10); lapply(letters |> rlang::set_names(), stringi::stri_detect_regex, p) |> purrr::reduce(rbind)
p <- sample(letters, 10); lapply(letters, stringi::stri_detect_regex, p) #|> purrr::reduce(rbind)
p <- sample(letters, 10) |> rlang::set_names(); lapply(letters, stringi::stri_detect_regex, p) |> purrr::reduce(rbind)
p <- sample(letters, 10) |> rlang::set_names(); lapply(letters, stringi::stri_detect_regex, p)# |> purrr::reduce(rbind)
p
p <- sample(letters, 10) |> rlang::set_names(); stringi::stri_detect_regex(letters, p)
p <- sample(letters, 10) |> rlang::set_names(); outer(letters, p, stringi::stri_detect_regex)
p <- sample(letters, 10); outer(letters, p, stringi::stri_detect_regex)
#
vlogical <- function(vector, vpattern, test, simplify_with = NULL, ...){
#' Vectorized Logical Tests
#'
#' \code{vlike} is a vectorized version of \code{\link[data.table]{like}} allowing a pattern vector to be supplied
#'
#' @param vector A vector or dimensional object to be processed (e.g., matrix, data.frame, etc.)
#' @param vpattern A named vector of patterns to be matched
#' @param test (function) The function to use for logical testing: the function should be appropriate for the values of \code{vpattern} accepting \code{vector} as the first argument, the pattern as the second, and '...' as the third (even if not used).
#' @param simplify_with (function) When provided, the function operates over rows, thereby simplifying the result
#' @param ... Additional arguments to be sent to the function held by argument \code{test}
#'
#' @return A logical matrix, with rows of the same length as \code{vector} and columns the length of \code{vpattern} TRUE for items that match pattern. If vector is dimensional, multiple \code{TRUE} values may be found for each row.
#'
#' @family Chapter 5 - Miscellaneous Functions
#'
#' @examples
# vlogical(
# 	vector = data.table::data.table(t(sapply(1:20, function(i){ c(a = sample(LETTERS, 1), b = sample(letters, 1)) })))
# 	, vpattern = c(sample(LETTERS, 5), sample(letters, 5))
# 	, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
# 	, simplify_with = mean
# 	, ignore.case = TRUE
# 	)
#'
#' @export
.default_test <- stringi::stri_detect_regex
if (missing(test) | !is.function(test)){ test <- .default_test }
if (is.character(test)){ test <- eval(as.symbol(test), envir = globalenv()) }
.nms <- which(rlang::names2(vpattern) == "")
if (!rlang::is_empty(.nms)){ names(vpattern)[.nms] <- paste0("x_", .nms) }
.out <- outer(vector, vpattern, test)
if (!rlang::is_empty(simplify_with)){
apply(.out, 1, simplify_with)
} else {
provideDimnames(.out, base = list(NULL, names(vpattern)))
}
vlogical(
vector = data.table::data.table(t(sapply(1:20, function(i){ c(a = sample(LETTERS, 1), b = sample(letters, 1)) })))
, vpattern = c(sample(LETTERS, 5), sample(letters, 5))
, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
, simplify_with = eval
, ignore.case = TRUE
)
vlogical(
vector = data.table::data.table(t(sapply(1:20, function(i){ c(a = sample(LETTERS, 1), b = sample(letters, 1)) })))
, vpattern = c(sample(LETTERS, 5), sample(letters, 5))
#, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
, simplify_with = eval
, ignore.case = TRUE
)
#
vlogical <- function(vector, vpattern, test = stringi::stri_detect_regex, simplify_with = NULL, ...){
#' Vectorized Logical Tests
#'
#' \code{vlike} is a vectorized version of \code{\link[data.table]{like}} allowing a pattern vector to be supplied
#'
#' @param vector A vector or dimensional object to be processed (e.g., matrix, data.frame, etc.)
#' @param vpattern A named vector of patterns to be matched
#' @param test (function) The function to use for logical testing: the function should be appropriate for the values of \code{vpattern} accepting \code{vector} as the first argument, the pattern as the second, and '...' as the third (even if not used).
#' @param simplify_with (function) When provided, the function operates over rows, thereby simplifying the result
#' @param ... Additional arguments to be sent to the function held by argument \code{test}
#'
#' @return A logical matrix, with rows of the same length as \code{vector} and columns the length of \code{vpattern} TRUE for items that match pattern. If vector is dimensional, multiple \code{TRUE} values may be found for each row.
#'
#' @family Chapter 5 - Miscellaneous Functions
#'
#' @examples
# vlogical(
# 	vector = data.table::data.table(t(sapply(1:20, function(i){ c(a = sample(LETTERS, 1), b = sample(letters, 1)) })))
# 	, vpattern = c(sample(LETTERS, 5), sample(letters, 5))
# 	, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
# 	, simplify_with = mean
# 	, ignore.case = TRUE
# 	)
#'
#' @export
.default_test <- stringi::stri_detect_regex
if (!is.function(test)){ test <- .default_test }
.nms <- which(rlang::names2(vpattern) == "")
if (!rlang::is_empty(.nms)){ names(vpattern)[.nms] <- paste0("x_", .nms) }
.out <- outer(vector, vpattern, test)
if (!rlang::is_empty(simplify_with)){
apply(.out, 1, simplify_with)
} else {
provideDimnames(.out, base = list(NULL, names(vpattern)))
}
vlogical(
vector = data.table::data.table(t(sapply(1:20, function(i){ c(a = sample(LETTERS, 1), b = sample(letters, 1)) })))
, vpattern = c(sample(LETTERS, 5), sample(letters, 5))
#, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
, simplify_with = eval
, ignore.case = TRUE
)
#
vlogical <- function(vector, vpattern, test = stringi::stri_detect_regex, simplify_with = NULL, ...){
#' Vectorized Logical Tests
#'
#' \code{vlike} is a vectorized version of \code{\link[data.table]{like}} allowing a pattern vector to be supplied
#'
#' @param vector A vector or dimensional object to be processed (e.g., matrix, data.frame, etc.)
#' @param vpattern A named vector of patterns to be matched
#' @param test (function) The function to use for logical testing: the function should be appropriate for the values of \code{vpattern} accepting \code{vector} as the first argument, the pattern as the second, and '...' as the third (even if not used).
#' @param simplify_with (function) When provided, the function operates over rows, thereby simplifying the result
#' @param ... Additional arguments to be sent to the function held by argument \code{test}
#'
#' @return A logical matrix, with rows of the same length as \code{vector} and columns the length of \code{vpattern} TRUE for items that match pattern. If vector is dimensional, multiple \code{TRUE} values may be found for each row.
#'
#' @family Chapter 5 - Miscellaneous Functions
#'
#' @examples
# vlogical(
# 	vector = data.table::data.table(t(sapply(1:20, function(i){ c(a = sample(LETTERS, 1), b = sample(letters, 1)) })))
# 	, vpattern = c(sample(LETTERS, 5), sample(letters, 5))
# 	, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
# 	, simplify_with = mean
# 	, ignore.case = TRUE
# 	)
#'
#' @export
.default_test <- stringi::stri_detect_regex
if (!is.function(test)){ test <- .default_test }
.nms <- which(rlang::names2(vpattern) == "")
if (!rlang::is_empty(.nms)){ names(vpattern)[.nms] <- paste0("x_", .nms) }
.out <- outer(vector, vpattern, test)
if (!rlang::is_empty(simplify_with)){
apply(.out, 2, simplify_with) |> t()
} else {
provideDimnames(.out, base = list(NULL, names(vpattern))) |> t()
}
vlogical(
vector = data.table::data.table(t(sapply(1:20, function(i){ c(a = sample(LETTERS, 1), b = sample(letters, 1)) })))
, vpattern = c(sample(LETTERS, 5), sample(letters, 5))
#, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
, simplify_with = eval
, ignore.case = TRUE
)
#
vlogical <- function(vector, vpattern, test = stringi::stri_detect_regex, simplify_with = NULL, ...){
#' Vectorized Logical Tests
#'
#' \code{vlike} is a vectorized version of \code{\link[data.table]{like}} allowing a pattern vector to be supplied
#'
#' @param vector A vector or dimensional object to be processed (e.g., matrix, data.frame, etc.)
#' @param vpattern A named vector of patterns to be matched
#' @param test (function) The function to use for logical testing: the function should be appropriate for the values of \code{vpattern} accepting \code{vector} as the first argument, the pattern as the second, and '...' as the third (even if not used).
#' @param simplify_with (function) When provided, the function operates over rows, thereby simplifying the result
#' @param ... Additional arguments to be sent to the function held by argument \code{test}
#'
#' @return A logical matrix, with rows of the same length as \code{vector} and columns the length of \code{vpattern} TRUE for items that match pattern. If vector is dimensional, multiple \code{TRUE} values may be found for each row.
#'
#' @family Chapter 5 - Miscellaneous Functions
#'
#' @examples
# vlogical(
# 	vector = data.table::data.table(t(sapply(1:20, function(i){ c(a = sample(LETTERS, 1), b = sample(letters, 1)) })))
# 	, vpattern = c(sample(LETTERS, 5), sample(letters, 5))
# 	, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
# 	, simplify_with = mean
# 	, ignore.case = TRUE
# 	)
#'
#' @export
.default_test <- stringi::stri_detect_regex
if (!is.function(test)){ test <- .default_test }
.nms <- which(rlang::names2(vpattern) == "")
if (!rlang::is_empty(.nms)){ names(vpattern)[.nms] <- paste0("x_", .nms) }
.out <- outer(vector, vpattern, test)
if (!rlang::is_empty(simplify_with)){
apply(.out, 1, simplify_with) |> t()
} else {
provideDimnames(.out, base = list(NULL, names(vpattern))) |> t()
}
vlogical(
vector = data.table::data.table(t(sapply(1:20, function(i){ c(a = sample(LETTERS, 1), b = sample(letters, 1)) })))
, vpattern = c(sample(LETTERS, 5), sample(letters, 5))
#, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
, simplify_with = eval
, ignore.case = TRUE
)
#
vlogical <- function(vector, vpattern, test = stringi::stri_detect_regex, simplify_with = NULL, ...){
#' Vectorized Logical Tests
#'
#' \code{vlike} is a vectorized version of \code{\link[data.table]{like}} allowing a pattern vector to be supplied
#'
#' @param vector A vector or dimensional object to be processed (e.g., matrix, data.frame, etc.)
#' @param vpattern A named vector of patterns to be matched
#' @param test (function) The function to use for logical testing: the function should be appropriate for the values of \code{vpattern} accepting \code{vector} as the first argument, the pattern as the second, and '...' as the third (even if not used).
#' @param simplify_with (function) When provided, the function operates over rows, thereby simplifying the result
#' @param ... Additional arguments to be sent to the function held by argument \code{test}
#'
#' @return A logical matrix, with rows of the same length as \code{vector} and columns the length of \code{vpattern} TRUE for items that match pattern. If vector is dimensional, multiple \code{TRUE} values may be found for each row.
#'
#' @family Chapter 5 - Miscellaneous Functions
#'
#' @examples
# vlogical(
# 	vector = data.table::data.table(t(sapply(1:20, function(i){ c(a = sample(LETTERS, 1), b = sample(letters, 1)) })))
# 	, vpattern = c(sample(LETTERS, 5), sample(letters, 5))
# 	, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
# 	, simplify_with = mean
# 	, ignore.case = TRUE
# 	)
#'
#' @export
.default_test <- stringi::stri_detect_regex
if (!is.function(test)){ test <- .default_test }
.nms <- which(rlang::names2(vpattern) == "")
if (!rlang::is_empty(.nms)){ names(vpattern)[.nms] <- paste0("x_", .nms) }
.out <- outer(vector, vpattern, test)
if (!rlang::is_empty(simplify_with)){ simplify_with(.out) } else { .out }
}
vlogical(
vector = data.table::data.table(t(sapply(1:20, function(i){ c(a = sample(LETTERS, 1), b = sample(letters, 1)) })))
, vpattern = c(sample(LETTERS, 5), sample(letters, 5))
#, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
, simplify_with = eval
, ignore.case = TRUE
)
vlogical(
vector = data.table::data.table(t(sapply(1:20, function(i){ c(a = sample(LETTERS, 1), b = sample(letters, 1)) })))
, vpattern = c(sample(LETTERS, 5), sample(letters, 5))
#, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
, simplify_with = any
, ignore.case = TRUE
)
vlogical(
vector = letters
, vpattern = c(sample(LETTERS, 5), sample(letters, 5))
#, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
, simplify_with = any
, ignore.case = TRUE
)
vlogical(
vector = letters
, vpattern = c(sample(LETTERS, 5), sample(letters, 5))
#, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
, simplify_with = colMeans
, ignore.case = TRUE
)
#
vlogical <- function(vector, vpattern, test = stringi::stri_detect_regex, simplify_with = NULL, ...){
#' Vectorized Logical Tests
#'
#' \code{vlike} is a vectorized version of \code{\link[data.table]{like}} allowing a pattern vector to be supplied
#'
#' @param vector A vector or dimensional object to be processed (e.g., matrix, data.frame, etc.)
#' @param vpattern A named vector of patterns to be matched
#' @param test (function) The function to use for logical testing: the function should be appropriate for the values of \code{vpattern} accepting \code{vector} as the first argument, the pattern as the second, and '...' as the third (even if not used).
#' @param simplify_with (function) A function to row-wise simplify the logical matrix when not empty
#' @param ... Additional arguments to be sent to the function held by argument \code{test}
#'
#' @return A logical matrix, with rows of the same length as \code{vector} and columns the length of \code{vpattern} TRUE for items that match pattern. If vector is dimensional, multiple \code{TRUE} values may be found for each row.
#'
#' @family Chapter 5 - Miscellaneous Functions
#'
#' @examples
# vlogical(
# 	vector = letters
# 	, vpattern = c(sample(LETTERS, 5), sample(letters, 5))
# 	, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
# 	, simplify_with = sum
# 	, ignore.case = TRUE
# 	)
#'
#' @export
.default_test <- stringi::stri_detect_regex
if (!is.function(test)){ test <- .default_test }
.nms <- which(rlang::names2(vpattern) == "")
if (!rlang::is_empty(.nms)){ names(vpattern)[.nms] <- paste0("x_", .nms) }
.out <- outer(vector, vpattern, test)
if (!rlang::is_empty(simplify_with)){ apply(.out, 1, simplify_with) } else { .out }
}
vlogical(
vector = letters
, vpattern = c(sample(LETTERS, 5), sample(letters, 5))
#, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
, simplify_with = mean
, ignore.case = TRUE
)
vlogical(
vector = letters
, vpattern = c(sample(LETTERS, 5), sample(letters, 5))
#, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
, simplify_with = sum
, ignore.case = TRUE
)
vlogical(
vector = letters
, vpattern = c(sample(LETTERS, 5), sample(letters, 5))
#, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
#, simplify_with = sum
, ignore.case = TRUE
)
#
vlogical <- function(vector, vpattern, test = stringi::stri_detect_regex, simplify_with = NULL, ...){
#' Vectorized Logical Tests
#'
#' \code{vlike} is a vectorized version of \code{\link[data.table]{like}} allowing a pattern vector to be supplied
#'
#' @param vector A vector or dimensional object to be processed (e.g., matrix, data.frame, etc.)
#' @param vpattern A named vector of patterns to be matched
#' @param test (function) The function to use for logical testing: the function should be appropriate for the values of \code{vpattern} accepting \code{vector} as the first argument, the pattern as the second, and '...' as the third (even if not used).
#' @param simplify_with (function) A function to row-wise simplify the logical matrix when not empty
#' @param ... Additional arguments to be sent to the function held by argument \code{test}
#'
#' @return A logical matrix, with rows of the same length as \code{vector} and columns the length of \code{vpattern} TRUE for items that match pattern. If vector is dimensional, multiple \code{TRUE} values may be found for each row.
#'
#' @family Chapter 5 - Miscellaneous Functions
#'
#' @examples
# vlogical(
# 	vector = letters
# 	, vpattern = c(sample(LETTERS, 5), sample(letters, 5))
# 	, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
# 	, simplify_with = sum
# 	, ignore.case = TRUE
# 	)
#'
#' @export
.default_test <- stringi::stri_detect_regex
if (!is.function(test)){ test <- .default_test }
.nms <- which(rlang::names2(vpattern) == "")
if (!rlang::is_empty(.nms)){ names(vpattern)[.nms] <- paste0("x_", .nms) }
.out <- outer(vector, vpattern, test)
if (!rlang::is_empty(simplify_with)){ apply(.out, 1, simplify_with) |> rlang::set_names(names(vpattern)) } else { .out }
}
vlogical(
vector = letters
, vpattern = c(sample(LETTERS, 5), sample(letters, 5))
#, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
#, simplify_with = sum
, ignore.case = TRUE
)
vlogical(
vector = letters
, vpattern = c(sample(LETTERS, 5), sample(letters, 5))
#, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
, simplify_with = sum
, ignore.case = TRUE
)
#
vlogical <- function(vector, vpattern, test = stringi::stri_detect_regex, simplify_with = NULL, ...){
#' Vectorized Logical Tests
#'
#' \code{vlike} is a vectorized version of \code{\link[data.table]{like}} allowing a pattern vector to be supplied
#'
#' @param vector A vector or dimensional object to be processed (e.g., matrix, data.frame, etc.)
#' @param vpattern A named vector of patterns to be matched
#' @param test (function) The function to use for logical testing: the function should be appropriate for the values of \code{vpattern} accepting \code{vector} as the first argument, the pattern as the second, and '...' as the third (even if not used).
#' @param simplify_with (function) A function to row-wise simplify the logical matrix when not empty
#' @param ... Additional arguments to be sent to the function held by argument \code{test}
#'
#' @return A logical matrix, with rows of the same length as \code{vector} and columns the length of \code{vpattern} TRUE for items that match pattern. If vector is dimensional, multiple \code{TRUE} values may be found for each row.
#'
#' @family Chapter 5 - Miscellaneous Functions
#'
#' @examples
# vlogical(
# 	vector = letters
# 	, vpattern = c(sample(LETTERS, 5), sample(letters, 5))
# 	, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
# 	, simplify_with = sum
# 	, ignore.case = TRUE
# 	)
#'
#' @export
.default_test <- stringi::stri_detect_regex
if (!is.function(test)){ test <- .default_test }
.nms <- which(rlang::names2(vpattern) == "")
if (!rlang::is_empty(.nms)){ names(vpattern)[.nms] <- paste0("x_", .nms) }
.out <- outer(vector, vpattern, test)
if (!rlang::is_empty(simplify_with)){ apply(.out, 1, simplify_with) |> t() |> rlang::set_names(names(vpattern)) } else { .out }
}
vlogical(
vector = letters
, vpattern = c(sample(LETTERS, 5), sample(letters, 5))
#, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
, simplify_with = sum
, ignore.case = TRUE
)
#
vlogical <- function(vector, vpattern, test = stringi::stri_detect_regex, simplify_with = NULL, ...){
#' Vectorized Logical Tests
#'
#' \code{vlike} is a vectorized version of \code{\link[data.table]{like}} allowing a pattern vector to be supplied
#'
#' @param vector A vector or dimensional object to be processed (e.g., matrix, data.frame, etc.)
#' @param vpattern A named vector of patterns to be matched
#' @param test (function) The function to use for logical testing: the function should be appropriate for the values of \code{vpattern} accepting \code{vector} as the first argument, the pattern as the second, and '...' as the third (even if not used).
#' @param simplify_with (function) A function to column-wise simplify the logical matrix when not empty
#' @param ... Additional arguments to be sent to the function held by argument \code{test}
#'
#' @return A logical matrix, with rows of the same length as \code{vector} and columns the length of \code{vpattern} TRUE for items that match pattern. If vector is dimensional, multiple \code{TRUE} values may be found for each row.
#'
#' @family Chapter 5 - Miscellaneous Functions
#'
#' @examples
# vlogical(
# 	vector = letters
# 	, vpattern = c(sample(LETTERS, 5), sample(letters, 5))
# 	, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
# 	, simplify_with = sum
# 	, ignore.case = TRUE
# 	)
#'
#' @export
.default_test <- stringi::stri_detect_regex
if (!is.function(test)){ test <- .default_test }
.nms <- which(rlang::names2(vpattern) == "")
if (!rlang::is_empty(.nms)){ names(vpattern)[.nms] <- paste0("x_", .nms) }
.out <- outer(vector, vpattern, test)
if (!rlang::is_empty(simplify_with)){ apply(.out, 2, simplify_with) |> rlang::set_names(names(vpattern)) } else { .out }
}
vlogical(
vector = letters
, vpattern = c(sample(LETTERS, 5), sample(letters, 5))
#, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
, simplify_with = sum
, ignore.case = TRUE
)
vlogical(
vector = letters
, vpattern = c(sample(LETTERS, 5), sample(letters, 5))
#, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
, simplify_with = mean
, ignore.case = TRUE
)
library(book.of.utilities)
rm(vlogical)
vlogical(
vector = letters
, vpattern = c(sample(LETTERS, 5), sample(letters, 5))
#, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
, simplify_with = mean
, ignore.case = TRUE
)
vlogical(
vector = rbind(letters, LETTERS)
, vpattern = c(sample(LETTERS, 5), sample(letters, 5))
#, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
, simplify_with = mean
, ignore.case = TRUE
)
vlogical(
vector = data.table::rbindlist(list(letters, LETTERS), use.names = FALSE)
, vpattern = c(sample(LETTERS, 5), sample(letters, 5))
#, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
, simplify_with = mean
, ignore.case = TRUE
)
vlogical(
vector = data.table::rbindlist(list(list(letters), list(LETTERS)), use.names = FALSE)
, vpattern = c(sample(LETTERS, 5), sample(letters, 5))
#, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
, simplify_with = mean
, ignore.case = TRUE
)
vlogical(
vector = data.table::rbindlist(list(list(letters), list(LETTERS)), use.names = FALSE)
, vpattern = c(sample(LETTERS, 5), sample(letters, 5))
#, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
#, simplify_with = mean
, ignore.case = TRUE
)
