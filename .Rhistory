, max.iter = 1000
, simplify = FALSE
)
inspect <- f(
x = sample(1000, size = 100)
, fun = \(x){ abs(x - mean(x, na.rm = TRUE)) |> print() }
, test = \(x){
if (is.na(sd(x))){
FALSE
} else {
i <- abs(x - mean(x, na.rm = TRUE))/sd(x);
mean(i > 3) <= 0.7
}
}
, nxt = \(x){ sample(1000, size = length(x)- 1) }
, max.iter = 1000
, simplify = FALSE
)
f <- function(x, fun, test, nxt, env = NULL, max.iter = 1, cur.iter = 0, simplify = TRUE){
#' Execute a Function as Recursively
#'
#' \code{as.recursive} creates a recursive version of the function passed to \code{fun}.
#'
#' @param x The input object
#' @param fun A function that operates on \code{x} and produces output
#' @param test A single-argument function returning a single Boolean: \code{FALSE} stops iteration
#' @param nxt A function that operates on the current output of \code{fun9x)} to send to the next iterative call to \code{fun()}
#' @param max.iter (integer) The maximum number of iterations
#' @param cur.iter (integer) The current iteration index
#' @param simplify (logical) Should only the last value be returned (\code{TRUE}) or intermediate values as well (\code{FALSE})?
#'
#' @importFrom magrittr %<>% %>%
#'
#' @export
#'
force(fun);
force(test);
force(nxt)
iterations <- list();
ans <- fun(x);
iterations[[1]] <- mget(c("ans", "test"));
while(test(ans) & (cur.iter < max.iter)){
cur.iter <- cur.iter + 1;
x <- nxt(ans);
ans <- fun(x); print(x); print(ans)
iterations[[cur.iter]] <- mget(c("cur.iter", "x", "ans")) |> purrr::modify_at(c("x", "ans"), list);
}
if (!simplify){
purrr::map(iterations, \(x) x$ans)
} else {
iterations[[length(iterations)]][["ans"]]
}
}
inspect <- f(
x = sample(1000, size = 100)
, fun = \(x){ abs(x - mean(x, na.rm = TRUE)) |> print() }
, test = \(x){
if (is.na(sd(x))){
FALSE
} else {
i <- abs(x - mean(x, na.rm = TRUE))/sd(x);
mean(i > 3) <= 0.7
}
}
, nxt = \(x){ sample(1000, size = length(x)- 1) }
, max.iter = 1000
, simplify = FALSE
)
f <- function(x, fun, test, nxt, env = NULL, max.iter = 1, cur.iter = 0, simplify = TRUE){
#' Execute a Function as Recursively
#'
#' \code{as.recursive} creates a recursive version of the function passed to \code{fun}.
#'
#' @param x The input object
#' @param fun A function that operates on \code{x} and produces output
#' @param test A single-argument function returning a single Boolean: \code{FALSE} stops iteration
#' @param nxt A function that operates on the current output of \code{fun9x)} to send to the next iterative call to \code{fun()}
#' @param max.iter (integer) The maximum number of iterations
#' @param cur.iter (integer) The current iteration index
#' @param simplify (logical) Should only the last value be returned (\code{TRUE}) or intermediate values as well (\code{FALSE})?
#'
#' @importFrom magrittr %<>% %>%
#'
#' @export
#'
force(fun);
force(test);
force(nxt)
iterations <- list();
ans <- fun(x);
iterations[[1]] <- mget(c("ans", "test"));
while(test(ans) & (cur.iter < max.iter)){
cur.iter <- cur.iter + 1;
x <- nxt(ans);
ans <- fun(x); print(ans)
iterations[[cur.iter]] <- mget(c("cur.iter", "x", "ans")) |> purrr::modify_at(c("x", "ans"), list);
}
if (!simplify){
purrr::map(iterations, \(x) x$ans)
} else {
iterations[[length(iterations)]][["ans"]]
}
}
inspect <- f(
x = sample(1000, size = 100)
, fun = \(x){ abs(x - mean(x, na.rm = TRUE)) |> print() }
, test = \(x){
if (is.na(sd(x))){
FALSE
} else {
i <- abs(x - mean(x, na.rm = TRUE))/sd(x);
mean(i > 3) <= 0.7
}
}
, nxt = \(x){ sample(1000, size = length(x)- 1) }
, max.iter = 1000
, simplify = FALSE
)
inspect <- f(
x = sample(1000, size = 100)
, fun = \(x){ abs(x - mean(x, na.rm = TRUE)) }
, test = \(x){
if (is.na(sd(x))){
FALSE
} else {
i <- abs(x - mean(x, na.rm = TRUE))/sd(x);
mean(i > 3) <= 0.7
}
}
, nxt = \(x){ sample(1000, size = length(x)- 1) }
, max.iter = 1000
, simplify = FALSE
)
inspect <- f(
x = sample(1000, size = 100)
, fun = \(x){ abs(x - mean(x, na.rm = TRUE)) }
, test = \(x){
if (length(unique(x)) > 1 || is.na(sd(x))){
FALSE
} else {
i <- abs(x - mean(x, na.rm = TRUE))/sd(x);
mean(i > 3) <= 0.7
}
}
, nxt = \(x){ sample(1000, size = length(x)- 1) }
, max.iter = 1000
, simplify = FALSE
)
f <- function(x, fun, test, nxt, env = NULL, max.iter = 1, cur.iter = 0, simplify = TRUE){
#' Execute a Function as Recursively
#'
#' \code{as.recursive} creates a recursive version of the function passed to \code{fun}.
#'
#' @param x The input object
#' @param fun A function that operates on \code{x} and produces output
#' @param test A single-argument function returning a single Boolean: \code{FALSE} stops iteration
#' @param nxt A function that operates on the current output of \code{fun9x)} to send to the next iterative call to \code{fun()}
#' @param max.iter (integer) The maximum number of iterations
#' @param cur.iter (integer) The current iteration index
#' @param simplify (logical) Should only the last value be returned (\code{TRUE}) or intermediate values as well (\code{FALSE})?
#'
#' @importFrom magrittr %<>% %>%
#'
#' @export
#'
force(fun);
force(test);
force(nxt)
iterations <- list();
ans <- fun(x);
iterations[[1]] <- mget(c("ans", "test"));
while(test(ans) & (cur.iter < max.iter)){
cur.iter <- cur.iter + 1;
x <- nxt(ans);
ans <- fun(x); print(ans)
iterations[[cur.iter]] <- mget(c("cur.iter", "x", "ans")) |> purrr::modify_at(c("x", "ans"), list);
}
if (!simplify){
purrr::map(iterations, \(x) x$ans)
} else {
iterations[[length(iterations)]][["ans"]]
}
}
inspect <- f(
x = sample(1000, size = 100)
, fun = \(x){ abs(x - mean(x, na.rm = TRUE)) }
, test = \(x){
if (length(unique(x)) > 1 || is.na(sd(x))){
FALSE
} else {
i <- abs(x - mean(x, na.rm = TRUE))/sd(x);
mean(i > 3) <= 0.7
}
}
, nxt = \(x){ sample(1000, size = length(x)- 1) }
, max.iter = 1000
, simplify = FALSE
)
inspect <- f(
x = sample(1000, size = 100)
, fun = \(x){ abs(x - mean(x, na.rm = TRUE)) }
, test = \(x){
if (length(unique(x)) == 1 || is.na(sd(x))){
FALSE
} else {
i <- abs(x - mean(x, na.rm = TRUE))/sd(x);
mean(i > 3) <= 0.7
}
}
, nxt = \(x){ sample(1000, size = length(x)- 1) }
, max.iter = 1000
, simplify = FALSE
)
inspect <- f(
x = sample(1000, size = 100)
, fun = \(x){ abs(x - mean(x, na.rm = TRUE)) }
, test = \(x){
if (length(unique(x)) == 1 || is.na(sd(x))){
FALSE
} else {
i <- abs(x - mean(x, na.rm = TRUE))/sd(x);
mean(i > 3) <= 0.7
}
}
, nxt = \(x){ sample(x, size = length(x)- 1) }
, max.iter = 1000
, simplify = FALSE
)
inspect <- f(
x = sample(1000, size = 100)
, fun = \(x){ abs(x - mean(x, na.rm = TRUE)) }
, test = \(x){
if (length(unique(x)) == 1 || is.na(sd(x))){
FALSE
} else {
i <- abs(x - mean(x, na.rm = TRUE))/sd(x);
mean(i > 3) <= 0.7
}
}
, nxt = \(x){ sample(x, size = length(x)- 1, prob = runif(n = length(x), min = 0.1, max = 0.9)) }
, max.iter = 1000
, simplify = FALSE
)
inspect <- purrr::map(inspect, \(x) unlist(x) |> sort())
inspect <- f(
x = sample(1000, size = 100)
, fun = \(x){ abs(x - mean(x, na.rm = TRUE)) }
, test = \(x){
if (length(unique(x)) == 1 || is.na(sd(x))){
FALSE
} else {
i <- abs(x - mean(x, na.rm = TRUE))/sd(x);
mean(i > 3) <= 0.7
}
}
, nxt = \(x){ sample(x, size = length(x)- 1, prob = runif(n = length(x), min = 0.1, max = 0.9)) }
, max.iter = 1000
, simplify = FALSE
)
inspect <- f(
x = sample(1000, size = 100)
, fun = \(x){ abs(x - mean(x, na.rm = TRUE)) }
, test = \(x){
if (length(unique(x)) == 1 || is.na(sd(x))){
FALSE
} else {
i <- abs(x - mean(x, na.rm = TRUE))/sd(x);
mean(i > 3) <= 0.7
}
}
, nxt = \(x){ sample(x, size = length(x)- 1, prob = runif(n = length(x), min = 0.1, max = 0.9)) }
, max.iter = 1000
, simplify = FALSE
)
inspect <- f(
x = sample(1000, size = 100)
, fun = \(x){ abs(x - mean(x, na.rm = TRUE)) }
, test = \(x){
if (length(unique(x)) == 1 || is.na(sd(x))){
FALSE
} else {
i <- abs(x - mean(x, na.rm = TRUE))/sd(x);
mean(i > 3) <= 0.7
}
}
, nxt = \(x){ sample(x, size = length(x)- 1, prob = runif(n = length(x), min = 0.1, max = 0.9)) }
, max.iter = 1000
, simplify = FALSE
)
inspect <- f(
x = sample(1000, size = 100)
, fun = \(x){ abs(x - mean(x, na.rm = TRUE)) }
, test = \(x){
if (length(unique(x)) == 1 || is.na(sd(x))){
FALSE
} else {
i <- abs(x - mean(x, na.rm = TRUE))/sd(x);
mean(i > 3) <= 0.7
}
}
, nxt = \(x){ sample(x, size = length(x)- 1, prob = runif(n = length(x), min = 0.1, max = 0.9)) }
, max.iter = 1000
, simplify = !FALSE
)
inspect <- f(
x = sample(1000, size = 100)
, fun = \(x){ abs(x - mean(x, na.rm = TRUE)) }
, test = \(x){
if (length(unique(x)) == 1 || is.na(sd(x))){
x <<- unique(x); FALSE
} else {
i <- abs(x - mean(x, na.rm = TRUE))/sd(x);
mean(i > 3) <= 0.7
}
}
, nxt = \(x){ sample(x, size = length(x)- 1, prob = runif(n = length(x), min = 0.1, max = 0.9)) }
, max.iter = 1000
, simplify = !FALSE
)
inspect <- f(
x = sample(1000, size = 100)
, fun = \(x){ abs(x - mean(x, na.rm = TRUE)) }
, test = \(x){
if (length(unique(x)) == 1 || is.na(sd(x))){
ans <<- unique(ans); FALSE
} else {
i <- abs(x - mean(x, na.rm = TRUE))/sd(x);
mean(i > 3) <= 0.7
}
}
, nxt = \(x){ sample(x, size = length(x)- 1, prob = runif(n = length(x), min = 0.1, max = 0.9)) }
, max.iter = 1000
, simplify = !FALSE
)
inspect <- f(
x = sample(1000, size = 100)
, fun = \(x){ abs(x - mean(x, na.rm = TRUE)) }
, test = \(x){
if (length(unique(x)) == 1 || is.na(sd(x))){
x <- unique(x); FALSE
} else {
i <- abs(x - mean(x, na.rm = TRUE))/sd(x);
mean(i > 3) <= 0.7
}
}
, nxt = \(x){ sample(x, size = length(x)- 1, prob = runif(n = length(x), min = 0.1, max = 0.9)) }
, max.iter = 1000
, simplify = !FALSE
)
call.recursion <- function(x, fun, test, nxt, env = NULL, max.iter = 1, cur.iter = 0, simplify = TRUE){
#' Execute a Function as Recursively
#'
#' \code{as.recursive} Executes a recursive calls to \code{fun} based on the output of \code{test} up to \code{max.iter} times
#'
#' @param x The input object
#' @param fun A function that operates on \code{x} and produces output
#' @param test A single-argument function returning a single Boolean: \code{FALSE} stops iteration
#' @param nxt A function that operates on the current output of \code{fun9x)} to send to the \emph{next} iterative call to \code{fun()}
#' @param max.iter (integer) The maximum number of iterations
#' @param cur.iter (integer) The current iteration index
#' @param simplify (logical) Should only the last value be returned (\code{TRUE}) or intermediate values as well (\code{FALSE})?
#'
#' @importFrom magrittr %<>% %>%
#'
#' @export
#'
force(fun);
force(test);
force(nxt)
iterations <- list();
ans <- fun(x);
iterations[[1]] <- mget(c("ans", "test"));
while(test(ans) & (cur.iter < max.iter)){
cur.iter <- cur.iter + 1;
x <- nxt(ans);
ans <- fun(x); print(ans)
iterations[[cur.iter]] <- mget(c("cur.iter", "x", "ans")) |> purrr::modify_at(c("x", "ans"), list);
}
if (!simplify){
purrr::map(iterations, \(x) x$ans)
} else {
iterations[[length(iterations)]][["ans"]]
}
}
call.recursion <- function(x, fun, test, nxt, env = NULL, max.iter = 1, cur.iter = 0, simplify = TRUE){
#' Execute a Function as Recursively
#'
#' \code{call.recursion} Executes a recursive calls to \code{fun} based on the output of \code{test} up to \code{max.iter} times
#'
#' @param x The input object
#' @param fun A function that operates on \code{x} and produces output
#' @param test A single-argument function returning a single Boolean: \code{FALSE} stops iteration
#' @param nxt A function that operates on the current output of \code{fun9x)} to send to the \emph{next} iterative call to \code{fun()}
#' @param max.iter (integer) The maximum number of iterations
#' @param cur.iter (integer) The current iteration index
#' @param simplify (logical) Should only the last value be returned (\code{TRUE}) or intermediate values as well (\code{FALSE})?
#'
#' @importFrom magrittr %<>% %>%
#'
#' @export
#'
force(fun);
force(test);
force(nxt)
iterations <- list();
ans <- fun(x);
iterations[[1]] <- mget(c("ans", "test"));
while(test(ans) & (cur.iter < max.iter)){
cur.iter <- cur.iter + 1;
x <- nxt(ans);
ans <- fun(x); print(ans)
iterations[[cur.iter]] <- mget(c("cur.iter", "x", "ans")) |> purrr::modify_at(c("x", "ans"), list);
}
if (!simplify){
purrr::map(iterations, \(x) x$ans)
} else {
iterations[[length(iterations)]][["ans"]]
}
}
recurs <- call.recursion(
x = sample(1000, size = 100)
, fun = \(x){ abs(x - mean(x, na.rm = TRUE)) }
, test = \(x){
if (length(unique(x)) == 1 || is.na(sd(x))){
FALSE
} else {
i <- abs(x - mean(x, na.rm = TRUE))/sd(x);
mean(i > 3) <= 0.7
}
}
, nxt = \(x){ sample(x, size = length(x)- 1, prob = runif(n = length(x), min = 0.1, max = 0.9)) }
, max.iter = 1000
, simplify = !FALSE
)
call.recursion <- function(x, fun, test, nxt, env = NULL, max.iter = 1, cur.iter = 0, simplify = TRUE){
#' Execute a Function as Recursively
#'
#' \code{call.recursion} Executes a recursive calls to \code{fun} based on the output of \code{test} up to \code{max.iter} times
#'
#' @param x The input object
#' @param fun A function that operates on \code{x} and produces output
#' @param test A single-argument function returning a single Boolean: \code{FALSE} stops iteration
#' @param nxt A function that operates on the current output of \code{fun9x)} to send to the \emph{next} iterative call to \code{fun()}
#' @param max.iter (integer) The maximum number of iterations
#' @param cur.iter (integer) The current iteration index
#' @param simplify (logical) Should only the last value be returned (\code{TRUE}) or intermediate values as well (\code{FALSE})?
#'
#' @importFrom magrittr %<>% %>%
#'
#' @export
#'
force(fun);
force(test);
force(nxt)
iterations <- list();
ans <- fun(x);
iterations[[1]] <- mget(c("ans", "test"));
while(test(ans) & (cur.iter < max.iter)){
cur.iter <- cur.iter + 1;
x <- nxt(ans);
ans <- fun(x);
iterations[[cur.iter]] <- mget(c("cur.iter", "x", "ans")) |> purrr::modify_at(c("x", "ans"), list);
}
if (!simplify){
purrr::map(iterations, \(x) x$ans)
} else {
iterations[[length(iterations)]][["ans"]]
}
}
library(book.of.utilities)
pkgdown::build_site(pkg = "pkg", lazy = TRUE, override = list(destination = "../docs"))
library(book.of.utilities)
pkgdown::build_site(pkg = "pkg", lazy = TRUE, override = list(destination = "../docs"))
pkgdown::build_site(pkg = "pkg", lazy = TRUE, override = list(destination = "../docs"))
library(book.of.utilities)
# List Output
x <- list(set_1 = sample(30, 10), set_2 = sample(90, 10))
print(x) |>
calc.harmonic_mean();
print(x) |>
calc.geo_mean();
x |> purrr::map_chr(\(i){ paste(collapse = ",")})
x |> purrr::map_chr(\(i){ paste(x, collapse = ",")})
# List Output
x <- list(set_1 = c(1, 26, 7, 21, 27, 3, 29, 24, 12, 20)
, set_2 = c(90, 78, 1, 54, 40, 11, 48, 20, 28, 22)
)
print(x) |>
calc.harmonic_mean();
print(x) |>
calc.geo_mean();
print(x) |>
calc.means(mean.type = c("am", "hm"));
# Array/Matrix output
print(x) |>
calc.means(post.op = simplify2array);
print(x) |>
calc.means(mean.type = c("am", "hm", "zm"), post.op = simplify2array) |> str()
print(x) |>
calc.means(mean.type = c("am", "hm", "zm"), post.op = simplify2array, as.zscore = TRUE) |> str()
print(x) |>
calc.means(mean.type = c("am", "hm", "zm"), post.op = simplify2array, as.zscore = TRUE, use.population = TRUE) |> str()
print(x) |>
calc.means(mean.type = c("am", "hm"));
print(x) |>
calc.means(mean.type = c("am", "hm", "zm", "gm"), post.op = simplify2array) |> str()
print(x) |>
calc.means(mean.type = c("am", "hm", "zm", "gm"), post.op = simplify2array) |> str()
print(x) |>
calc.means(mean.type = c("am", "hm", "zm", "gm"), post.op = simplify2array)
library(book.of.utilities)
pkgdown::build_site(pkg = "pkg", lazy = TRUE, override = list(destination = "../docs"))
