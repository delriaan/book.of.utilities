f(imperial_auth)
f <- function(data){
kr_name <- rlang::enexpr(data) |> rlang::as_label()
if (missing(data)){ stop("No keyring data provided") }
if (is.raw(data)){ data <- rawToChar(data) }
kr_args <- jsonlite::fromJSON(data)
# rlang::set_names(c("keyring", "service", "username", "password"))
purrr::pmap(kr_args, function(...) rlang::expr(do.call(keyring::key_set_with_value, args = !!rlang::list2(keyring = kr_name, ...))))
}
f(imperial_auth)
f <- function(data){
kr_name <- rlang::enexpr(data) |> rlang::as_label()
if (missing(data)){ stop("No keyring data provided") }
if (is.raw(data)){ data <- rawToChar(data) }
kr_args <- jsonlite::fromJSON(data)
# rlang::set_names(c("keyring", "service", "username", "password"))
purrr::pmap(kr_args, \(...) rlang::expr(do.call(keyring::key_set_with_value, args = !!rlang::list2(keyring = kr_name, ...))))
}
f(imperial_auth)
f <- function(data){
kr_name <- rlang::enexpr(data) |> rlang::as_label()
if (missing(data)){ stop("No keyring data provided") }
if (is.raw(data)){ data <- rawToChar(data) }
kr_args <- jsonlite::fromJSON(data)
purrr::pmap(kr_args, \(...){
rlang::expr(
do.call(
what = keyring::key_set_with_value
, args = !!rlang::list2(keyring = kr_name, ...) |> rlang::set_names(c("keyring", "service", "username", "password"))
))
})
}
f(imperial_auth)
f <- function(data){
kr_name <- rlang::enexpr(data) |> rlang::as_label()
if (missing(data)){ stop("No keyring data provided") }
if (is.raw(data)){ data <- rawToChar(data) }
kr_args <- jsonlite::fromJSON(data)
purrr::pmap(kr_args, \(...){
rlang::expr(
keyring::key_set_with_value(!!rlang::list2(keyring = kr_name, ...) |>
rlang::set_names(c("keyring", "service", "username", "password"))
))
})
}
f(imperial_auth)
f <- function(data){
kr_name <- rlang::enexpr(data) |> rlang::as_label()
if (missing(data)){ stop("No keyring data provided") }
if (is.raw(data)){ data <- rawToChar(data) }
kr_args <- jsonlite::fromJSON(data)
purrr::pmap(kr_args, \(...){
rlang::expr(
keyring::key_set_with_value(!!!rlang::list2(keyring = kr_name, ...) |>
rlang::set_names(c("keyring", "service", "username", "password"))
))
})
}
f(imperial_auth)
f <- function(data){
kr_name <- rlang::enexpr(data) |> rlang::as_label()
if (missing(data)){ stop("No keyring data provided") }
if (is.raw(data)){ data <- rawToChar(data) }
kr_args <- jsonlite::fromJSON(data)
purrr::pmap(kr_args, \(...){
rlang::expr(
keyring::key_set_with_value(
!!!rlang::list2(keyring = kr_name, ...) |>
purrr::map(\(x) if (x == ""){ NULL } else { x }) |>
rlang::set_names(c("keyring", "service", "username", "password"))
))
})
}
f(imperial_auth)
f <- function(data, dry.run = FALSE){
kr_name <- rlang::enexpr(data) |> rlang::as_label()
if (missing(data)){ stop("No keyring data provided") }
if (is.raw(data)){ data <- rawToChar(data) }
kr_args <- jsonlite::fromJSON(data)
purrr::pwalk(kr_args, \(...){
.action <- { rlang::expr(
keyring::key_set_with_value(
!!!rlang::list2(keyring = kr_name, ...) |>
purrr::map(\(x) if (x == ""){ NULL } else { x }) |>
rlang::set_names(c("keyring", "service", "username", "password"))
)
)}
if (dry.run){ rlang::expr_print(.action) } else { eval(.action) }
})
}
f(imperial_auth, TRUE)
f <- function(data, dry.run = FALSE){
kr_name <- rlang::enexpr(data) |> rlang::as_label()
if (missing(data)){ stop("No keyring data provided") }
if (is.raw(data)){ data <- rawToChar(data) }
kr_args <- jsonlite::fromJSON(data)
purrr::pwalk(kr_args, \(...){
.action <- { rlang::expr(
keyring::key_set_with_value(
!!!rlang::list2(keyring = kr_name, ...) |>
purrr::map(\(x) if (x == ""){ NULL } else { x }) |>
rlang::set_names(c("keyring", "service", "username", "password"))
)
)}
if (dry.run){
.action$password <- "<redacted>"
rlang::expr_print(.action)
} else {
eval(.action)
}
})
}
f(imperial_auth, TRUE)
f <- function(data, dry.run = FALSE){
kr_name <- rlang::enexpr(data) |> rlang::as_label()
if (missing(data)){ stop("No keyring data provided") }
if (is.raw(data)){ data <- rawToChar(data) }
kr_args <- jsonlite::fromJSON(data)
purrr::pwalk(kr_args, \(...){
.action <- { rlang::expr(
keyring::key_set_with_value(
!!!rlang::list2(keyring = kr_name, ...) |>
purrr::map(\(x) if (x == ""){ NULL } else { x }) |>
rlang::set_names(c("keyring", "service", "username", "password"))
)
)}
if (dry.run){
.action$password <- `<redacted>`
rlang::expr_print(.action)
} else {
eval(.action)
}
})
}
f(imperial_auth, TRUE)
f <- function(data, dry.run = FALSE){
kr_name <- rlang::enexpr(data) |> rlang::as_label()
if (missing(data)){ stop("No keyring data provided") }
if (is.raw(data)){ data <- rawToChar(data) }
kr_args <- jsonlite::fromJSON(data)
purrr::pwalk(kr_args, \(...){
.action <- { rlang::expr(
keyring::key_set_with_value(
!!!rlang::list2(keyring = kr_name, ...) |>
purrr::map(\(x) if (x == ""){ NULL } else { x }) |>
rlang::set_names(c("keyring", "service", "username", "password"))
)
)}
if (dry.run){
.action$password <- quote(`<redacted>`)
rlang::expr_print(.action)
} else {
eval(.action)
}
})
}
f(imperial_auth, TRUE)
~
.
~password
f <- function(data, dry.run = FALSE){
kr_name <- rlang::enexpr(data) |> rlang::as_label()
if (missing(data)){ stop("No keyring data provided") }
if (is.raw(data)){ data <- rawToChar(data) }
kr_args <- jsonlite::fromJSON(data)
purrr::pwalk(kr_args, \(...){
.action <- { rlang::expr(
keyring::key_set_with_value(
!!!rlang::list2(keyring = kr_name, ...) |>
purrr::map(\(x) if (x == ""){ NULL } else { x }) |>
rlang::set_names(c("keyring", "service", "username", "password"))
)
)}
if (dry.run){
.action$password <- ~password
rlang::expr_print(.action)
} else {
eval(.action)
}
})
}
f(imperial_auth, TRUE)
f <- function(data, dry.run = FALSE){
kr_name <- rlang::enexpr(data) |> rlang::as_label()
if (missing(data)){ stop("No keyring data provided") }
if (is.raw(data)){ data <- rawToChar(data) }
kr_args <- jsonlite::fromJSON(data)
purrr::pwalk(kr_args, \(...){
.action <- { rlang::expr(
keyring::key_set_with_value(
!!!rlang::list2(keyring = kr_name, ...) |>
purrr::map(\(x) if (x == ""){ NULL } else { x }) |>
rlang::set_names(c("keyring", "service", "username", "password"))
)
)}
if (dry.run){
.action$password <- quote(password)
rlang::expr_print(.action)
} else {
eval(.action)
}
})
}
f(imperial_auth, TRUE)
f <- function(data, dry.run = FALSE){
kr_name <- rlang::enexpr(data) |> rlang::as_label()
if (missing(data)){ stop("No keyring data provided") }
if (is.raw(data)){ data <- rawToChar(data) }
kr_args <- jsonlite::fromJSON(data)
purrr::pwalk(kr_args, \(...){
.action <- { rlang::expr(
keyring::key_set_with_value(
!!!rlang::list2(keyring = kr_name, ...) |>
purrr::map(\(x) if (x == ""){ NULL } else { x }) |>
rlang::set_names(c("keyring", "service", "username", "password"))
)
)}
if (dry.run){
.action$password <- "####"
rlang::expr_print(.action)
} else {
eval(.action)
}
})
}
f(imperial_auth, TRUE)
f <- function(data, dry.run = FALSE){
kr_name <- rlang::enexpr(data) |> rlang::as_label()
if (missing(data)){ stop("No keyring data provided") }
if (is.raw(data)){ data <- rawToChar(data) }
kr_args <- jsonlite::fromJSON(data)
purrr::pwalk(kr_args, \(...){
.action <- { rlang::expr(
keyring::key_set_with_value(
!!!rlang::list2(keyring = kr_name, ...) |>
purrr::map(\(x) if (x == ""){ NULL } else { x }) |>
rlang::set_names(c("keyring", "service", "username", "password"))
)
)}
if (dry.run){
.action$password <- "*****"
rlang::expr_print(.action)
} else {
eval(.action)
}
})
}
f(imperial_auth, TRUE)
f <- function(data, dry.run = FALSE){
kr_name <- rlang::enexpr(data) |> rlang::as_label()
if (missing(data)){ stop("No keyring data provided") }
if (is.raw(data)){ data <- rawToChar(data) }
kr_args <- jsonlite::fromJSON(data)
purrr::pwalk(kr_args, \(...){
.action <- { rlang::expr(
keyring::key_set_with_value(
!!!rlang::list2(keyring = kr_name, ...) |>
purrr::map(\(x) if (x == ""){ NULL } else { x }) |>
rlang::set_names(c("keyring", "service", "username", "password"))
)
)}
if (dry.run){
.action$password <- expression(...)
rlang::expr_print(.action)
} else {
eval(.action)
}
})
}
f(imperial_auth, TRUE)
f <- function(data, dry.run = FALSE){
kr_name <- rlang::enexpr(data) |> rlang::as_label()
if (missing(data)){ stop("No keyring data provided") }
if (is.raw(data)){ data <- rawToChar(data) }
kr_args <- jsonlite::fromJSON(data)
purrr::pwalk(kr_args, \(...){
.action <- { rlang::expr(
keyring::key_set_with_value(
!!!rlang::list2(keyring = kr_name, ...) |>
purrr::map(\(x) if (x == ""){ NULL } else { x }) |>
rlang::set_names(c("keyring", "service", "username", "password"))
)
)}
if (dry.run){
.action$password <- "..."
rlang::expr_print(.action)
} else {
eval(.action)
}
})
}
f(imperial_auth, TRUE)
f <- function(data, dry.run = FALSE){
kr_name <- rlang::enexpr(data) |> rlang::as_label()
if (missing(data)){ stop("No keyring data provided") }
if (is.raw(data)){ data <- rawToChar(data) }
kr_args <- jsonlite::fromJSON(data)
purrr::pwalk(kr_args, \(...){
.action <- { rlang::expr(
keyring::key_set_with_value(
!!!rlang::list2(keyring = kr_name, ...) |>
purrr::map(\(x) if (x == ""){ NULL } else { x }) |>
rlang::set_names(c("keyring", "service", "username", "password"))
)
)}
if (dry.run){
.action$password <- "..."
rlang::expr_print(.action)
} else {
tryCatch({ eval(.action); TRUE }, error = \(e) FALSE)
}
})
}
f <- function(data, dry.run = FALSE){
kr_name <- rlang::enexpr(data) |> rlang::as_label()
if (missing(data)){ stop("No keyring data provided") }
if (is.raw(data)){ data <- rawToChar(data) }
kr_args <- jsonlite::fromJSON(data)
purrr::pwalk(kr_args, \(...){
.action <- { rlang::expr(
keyring::key_set_with_value(
!!!rlang::list2(keyring = kr_name, ...) |>
purrr::map(\(x) if (x == ""){ NULL } else { x }) |>
rlang::set_names(c("keyring", "service", "username", "password"))
)
)}
if (dry.run){
.action$password <- "..."
rlang::expr_print(.action)
TRUE
} else {
tryCatch({ eval(.action); TRUE }, error = \(e) FALSE)
}
})
}
f(imperial_auth, TRUE)
f <- function(data, dry.run = FALSE){
kr_name <- rlang::enexpr(data) |> rlang::as_label()
if (missing(data)){ stop("No keyring data provided") }
if (is.raw(data)){ data <- rawToChar(data) }
kr_args <- jsonlite::fromJSON(data)
purrr::pmap(kr_args, \(...){
.action <- { rlang::expr(
keyring::key_set_with_value(
!!!rlang::list2(keyring = kr_name, ...) |>
purrr::map(\(x) if (x == ""){ NULL } else { x }) |>
rlang::set_names(c("keyring", "service", "username", "password"))
)
)}
if (dry.run){
.action$password <- "..."
rlang::expr_print(.action)
TRUE
} else {
tryCatch({ eval(.action); TRUE }, error = \(e) FALSE)
}
})
}
f(imperial_auth, TRUE)
f <- function(data, dry.run = FALSE){
kr_name <- rlang::enexpr(data) |> rlang::as_label()
if (missing(data)){ stop("No keyring data provided") }
if (is.raw(data)){ data <- rawToChar(data) }
kr_args <- jsonlite::fromJSON(data)
purrr::pmap_lgl(kr_args, \(...){
.action <- { rlang::expr(
keyring::key_set_with_value(
!!!rlang::list2(keyring = kr_name, ...) |>
purrr::map(\(x) if (x == ""){ NULL } else { x }) |>
rlang::set_names(c("keyring", "service", "username", "password"))
)
)}
if (dry.run){
.action$password <- "..."
rlang::expr_print(.action)
TRUE
} else {
tryCatch({ eval(.action); TRUE }, error = \(e) FALSE)
}
})
}
f(imperial_auth, TRUE)
dir("pkg/R", full.names = TRUE) |> sapply(source)
library(magrittr, include.only = c("%<>%", "%>%"));
# custom operators ----
x <- data.table::data.table(i = sample(100, 10), j = sample(100, 10), key = c("i", "j")) |> unique()
y <- data.table::data.table(i = sample(200, 10, TRUE), j = sample(200, 10, TRUE), key = c("i", "j")) |> unique()
(z <- x %><% y) |> str()
(q <- x %tf% y) |> str()
# custom operators ----
x <- data.frame(i = sample(100, 10), j = sample(100, 10), key = c("i", "j")) |> unique()
y <- data.frame(i = sample(200, 10, TRUE), j = sample(200, 10, TRUE), key = c("i", "j")) |> unique()
(z <- x %><% y) |> str()
(q <- x %tf% y) |> str()
# debug(`%??%`)
(v <- data.table::data.table(y$i > mean(y$i), y$j <= mean(y$j)) %??% q) |> str()
v
#
# enlist() ====
# :: Test Objects
test_x = list(
test_1 = c(1:5)
, test_2 = list(c(1:5), 3, 4, c(letters[1:5]))
);
nms = c("up", "down", "left", "right", "center");
# :: Unnamed Vector -> Elements become names
enlist(test_x$test_1);
enlist(test_x$test_2);
# :: Unnamed Vector & Provided Names (Full) -> All elements have names in 'nms'
enlist(test_x$test_1, nms);
enlist(test_x$test_2, !!!nms);
enlist(test_x$test_2, up, down, left, right, center);
# %>% Unnamed Vector & Provided Names (Partial) -> First two names are 'nms[1:2]' with the balance as default
enlist(test_x$test_1, !!!nms[1:2]);
enlist(test_x$test_2, !!!nms[1:2])
test_x$test_1
#
# vlogical() ====
vlogical(
vector = data.table::data.table(t(sapply(1:100000, function(i){ c(a = sample(LETTERS, 1), b = sample(letters, 1)) })))
, c(sample(LETTERS, 5), sample(letters, 5))
, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
, simplify_with = mean
, ignore.case = TRUE
)
#
vlogical <- function(vector, vpattern, test, simplify_with = NULL, ...){
#' Vectorized Logical Tests
#'
#' \code{vlike} is a vectorized version of \code{\link[data.table]{like}} allowing a pattern vector to be supplied
#'
#' @param vector A vector or dimensional object to be processed (e.g., matrix, data.frame, etc.)
#' @param vpattern A vector of patterns to be matched
#' @param test (function) The function to use for logical testing: the function should be appropriate for the values of \code{vpattern} and have a named argument of \code{vector}, an additional argument to accept the pattern fed atomically, and '...' (even if not used).
#' @param simplify_with (function) When provided, the function operates over rows, thereby simplifying the result
#' @param ... Additional arguments to be sent to the function held by argument \code{test}
#'
#' @return A logical matrix, with rows of the same length as \code{vector} and columns the length of \code{vpattern} TRUE for items that match pattern. If vector is dimensional, multiple \code{TRUE} values may be found for each row.
#' @family Chapter 5 - Miscellaneous Functions
#' @export
if (missing(test)){ test <- data.table::like }
if (is.character(test)){ test <- eval(as.symbol(test), envir = globalenv()) }
if (!is.function(test)){
message("Argument 'test' is not a function: using default (data.table::like)");
test <- data.table::like;
}
sub_fn = function(v, ...){ sapply(vpattern, purrr::as_mapper(~test(v, .x, ...))) }
if ("list" %in% class(vector)){ vector <- unlist(vector); }
.out = if (any(c("matrix", "array", "data.table", "data.frame", "tibble") %in% class(vector))){
t(apply(vector, 1, sub_fn, ...))
} else { sub_fn(vector, ...)}
if (!rlang::is_empty(simplify_with)){
apply(.out, 1, simplify_with)
} else {
provideDimnames(.out, base = list(NULL, c(vpattern)))
}
#
# vlogical() ====
vlogical(
vector = data.table::data.table(t(sapply(1:100000, function(i){ c(a = sample(LETTERS, 1), b = sample(letters, 1)) })))
, c(sample(LETTERS, 5), sample(letters, 5))
, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
, simplify_with = mean
, ignore.case = TRUE
)
#
vlogical <- function(vector, vpattern, test, simplify_with = NULL, ...){
#' Vectorized Logical Tests
#'
#' \code{vlike} is a vectorized version of \code{\link[data.table]{like}} allowing a pattern vector to be supplied
#'
#' @param vector A vector or dimensional object to be processed (e.g., matrix, data.frame, etc.)
#' @param vpattern A vector of patterns to be matched
#' @param test (function) The function to use for logical testing: the function should be appropriate for the values of \code{vpattern} and have a named argument of \code{vector}, an additional argument to accept the pattern fed atomically, and '...' (even if not used).
#' @param simplify_with (function) When provided, the function operates over rows, thereby simplifying the result
#' @param ... Additional arguments to be sent to the function held by argument \code{test}
#'
#' @return A logical matrix, with rows of the same length as \code{vector} and columns the length of \code{vpattern} TRUE for items that match pattern. If vector is dimensional, multiple \code{TRUE} values may be found for each row.
#' @family Chapter 5 - Miscellaneous Functions
#' @export
if (missing(test)){
test <- data.table::like
}
if (is.character(test)){
test <- eval(as.symbol(test), envir = globalenv())
}
if (!is.function(test)){
message("Argument 'test' is not a function: using default (data.table::like)");
test <- data.table::like;
}
sub_fn = function(v, ...){ sapply(vpattern, purrr::as_mapper(\(x) test(v, x, ...))) }
if ("list" %in% class(vector)){
vector <- unlist(vector);
}
.out = if (any(c("matrix", "array", "data.table", "data.frame", "tibble") %in% class(vector))){
t(apply(vector, 1, sub_fn, ...))
} else { sub_fn(vector, ...)}
if (!rlang::is_empty(simplify_with)){
apply(.out, 1, simplify_with)
} else {
provideDimnames(.out, base = list(NULL, c(vpattern)))
}
library(book.of.utilities)
#
# Build Site ----
# usethis::use_pkgdown()
pkgdown::build_site(pkg = "pkg", lazy = TRUE, override = list(destination = "../docs"))
library(book.of.utilities)
#
# Build Site ----
# usethis::use_pkgdown()
pkgdown::build_site(pkg = "pkg", lazy = TRUE, override = list(destination = "../docs"))
