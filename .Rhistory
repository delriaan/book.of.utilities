jsonlite::fromJSON(kr_data)
})
}
keyring_export(keyring = "R", TRUE) |> keyring_import()
keyring_import <- function(data, ...){
c(data, rlang::list2(...)) |>
purrr::imap(~{
keyring <- .y
kr_data <- if (is.raw(.x)){ rawToChar(.x) } else { .x }
jsonlite::fromJSON(kr_data) |>
purrr::pmap(~{
keyring::key_set_with_value(service = !!..1, username = !!..2, password = !!..3, keyring = !!keyring)
})
}
keyring_export(keyring = "R", TRUE) |> keyring_import()
keyring_import <- function(data, ...){
c(data, rlang::list2(...)) |>
purrr::imap(~{
keyring <- .y
kr_data <- if (is.raw(.x)){ rawToChar(.x) } else { .x }
jsonlite::fromJSON(kr_data) |>
purrr::pmap(~{
rlang::expr(
keyring::key_set_with_value(service = !!..1, username = !!..2, password = !!..3, keyring = !!keyring)
)
})
}
keyring_export(keyring = "R", TRUE) |> keyring_import()
purrr::imap(c(1, b = 4), ~class(.y))
purrr::imap(c(1, b = 4), ~rlang::is_empty(.y))
purrr::imap(c(1, b = 4), ~str(.y))
which(names(1:10) == "") |> paste(collapse = ",")
which(names(1:10) == "") #|> paste(collapse = ",")
paste(1, collapse = ",")
paste(c(1, 4), collapse = ",")
keyring_import <- function(data, ...){
#' Import keyring Entries
#'
#' \code{keyring_import} registers exported \code{\link[keyring]{keyring}}s (see \code{\link{keyring_export}})
#'
#' @param data The named list of exported keyring data
#' @param ... Additional named keyring entries
#' @param as.raw (logical | FALSE) Should each entry be cast as a raw vector?
#'
#' @note Unnamed inputs will not be imported but indicated via console message
#'
#' @return Keyring entries as JSON or raw-encoded JSON
#' @family keyring Utilities
#' @export
data <- append(data, rlang::list2(...));
no.names <- which(names(data) == "")
if (!identical(integer(), no.names)){
message(sprintf("Entries at the following positions will not be imported: %s", paste(no.names, collapse = ", ")))
}
data <- data[-no.names];
if (rlang::is_empty(data)){
message("No action taken (all entries are unnamed): exiting ..."); return()
}
purrr::iwalk(data, ~{
keyring <- .y
kr_data <- if (is.raw(.x)){ rawToChar(.x) } else { .x }
jsonlite::fromJSON(kr_data) |>
purrr::pwalk(~{
keyring::key_set_with_value(
service 		= ..1
, username	= ..2
, password	= ..3
, keyring 	= keyring
)
})
}
keyring_export(keyring = "R", TRUE) |> keyring_import(c(3))
keyring_export(keyring = "R", TRUE)
keyring_export(keyring = "R", !TRUE)
library(book.of.utilities)
library(book.of.utilities)
gen_pass(length = 12)
gen_pass(length = 12) |> writeClipboard()
gen_pass(length = 20) |> writeClipboard()
dir("pkg/R", full.names = TRUE)
dir("pkg/R", full.names = TRUE) |> source()
dir("pkg/R", full.names = TRUE) |> sapply(source)
# calc.means() ====
calc.means(sample(30, 10) |> print());
library(magrittr, include.only = c("%<>%", "%>%"));
# calc.means() ====
calc.means(sample(30, 10) |> print());
calc.means(sample(30, 10) |> print(), "hm");
calc.means(sample(30, 10) |> print(), mean.type = c("am", "hm"));
x <- sample(100, 50)
calc.zero_mean(x)
calc.zero_mean(x, as.zscore = TRUE)
calc.zero_mean(x, use.population = TRUE )
calc.zero_mean(x, as.zscore = TRUE, use.population = TRUE)
# List Output
x <- list(set_1 = sample(30, 10), set_2 = sample(90, 10))
print(x) |>
calc.harmonic_mean();
print(x) |>
calc.means(mean.type = c("am", "hm"));
# Array/Matrix output
print(x) |>
calc.means(post.op = simplify2array);
print(x) |>
calc.means(mean.type = c("am", "hm", "zm"), post.op = simplify2array) |> str()
print(x) |>
calc.means(mean.type = c("am", "hm", "zm"), post.op = simplify2array, as.zscore = TRUE) |> str()
print(x) |>
calc.means(mean.type = c("am", "hm", "zm"), post.op = simplify2array, as.zscore = TRUE, use.population = TRUE) |> str()
#
# enlist() ====
# :: Test Objects
test_x = list(
test_1 = c(1:5)
, test_2 = list(c(1:5), 3, 4, c(letters[1:5]))
);
nms = c("up", "down", "left", "right", "center");
# :: Unnamed Vector -> Elements become names
enlist(test_x$test_1);
enlist(test_x$test_2);
# :: Unnamed Vector & Provided Names (Full) -> All elements have names in 'nms'
enlist(test_x$test_1, nms);
enlist(test_x$test_2, !!!nms);
enlist(test_x$test_2, up, down, left, right, center);
# %>% Unnamed Vector & Provided Names (Partial) -> First two names are 'nms[1:2]' with the balance as default
enlist(test_x$test_1, !!!nms[1:2]);
enlist(test_x$test_2, !!!nms[1:2])
#
# vlogical() ====
vlogical(
vector = data.table::data.table(t(sapply(1:100000, function(i){ c(a = sample(LETTERS, 1), b = sample(letters, 1)) })))
, c(sample(LETTERS, 5), sample(letters, 5))
, test = function(vector, q, ...){ any(unique(vector) %in% unique(q))}
, simplify_with = mean
, ignore.case = TRUE
)
# ----
get.object_sizes() |> View()
#
# *regex ====
as.regex("test") |> is.regex() # TRUE
c(as.regex("test", "this"), "or_that") |> is.regex() # TRUE TRUE FALSE
unregex(i = c(as.regex("mp|[cye]+"), "hp", "hq"), x = colnames(mtcars)) #  "mpg"  "cyl"  "qsec" "gear" "carb" "hp
unregex(i = c(as.regex("mp|[cye]+"), "hp", "hq"), x = mtcars) #  "mpg"  "cyl"  "qsec" "gear" "carb" "hp
# Custom operators ----
x <- data.table::data.table(i = sample(100, 10), j = sample(100, 10), key = c("i", "j")) |> unique()
y <- data.table::data.table(i = sample(200, 10, TRUE), j = sample(200, 10, TRUE), key = c("i", "j")) |> unique()
(z <- x %><% y) |> str()
(q <- x %::% y) |> str()
(q <- x %tf% y) |> str()
(v <- z %??% q) |> str()
#
`%??%` <- function(cond, result){
purrr::reduce(v$result, rbind)
}
#
`%??%` <- function(cond, result){
#' Correlated IF-THEN-ELSE Comparison
#'
#' For each element \code{E} in \code{cond}, when \code{E} is \code{TRUE}, the corresponding index of \code{result$true} is returned: the same for \code{cond == FALSE}.
#' For \code{result}, the easiest way to set the available choices is to use \code{\link{\%tf\%}}; otherwise, a environment(-like) object with members named \code{true} and \code{false}
#'
#' @param cond (logical) A \emph{vector} or \emph{tensor} that evaluates to \code{TRUE} or \code{FALSE}
#' @param result (vector) Resultant values for TRUE and FALSE conditionals, ideally stored in a dimension-ed object (e.g, \code{\link[base]{data.frame}}, \code{\link[data.table]{data.table}})
#'
#' @family Custom operators
#'
#' @export
#'
if (is.environment(result)){ result <- data.table::as.data.table(mget(c("true", "false"), envir = result)) }
if (!data.table::is.data.table(result)){ result <- data.table::as.data.table(result) }
purrr::map2(cond, purrr::array_branch(result, margin = 1), `%?%`) |> purrr::list_rbind()
}
(v <- z %??% q) |> str()
v$result
z
(v <- y$i > mean(y$i) %??% q) |> str()
(v <- list(y$i > mean(y$i), y$j <= mean(y$j)) %??% q) |> str()
# as.recursive() ====
fun <- as.recursive(
fun = function(...){
sample(rlang::list2(...) |> unlist() |> as.vector(), size = 10, replace = TRUE)
}
, cond_def = ~mean(.) <= median(.)
, finalize = ~list(x = rlang::set_names(., seq_along(.)), y = reduce(., ~mean(c(.x, .x + .y), na.rm = TRUE)))
)
(inspect <- fun(!!!c(1:100)))
# as.recursive() ====
fun <- as.recursive(
fun = function(...){
sample(rlang::list2(...) |> unlist() |> as.vector(), size = 10, replace = TRUE)
}
, cond_def = ~mean(.) <= median(.)
, finalize = ~list(x = rlang::set_names(., seq_along(.)), y = purrr::reduce(., ~mean(c(.x, .x + .y), na.rm = TRUE)))
)
(inspect <- fun(!!!c(1:100)))
debug(`%??%`)
(v <- list(y$i > mean(y$i), y$j <= mean(y$j)) %??% q) |> str()
force(cond)
(v <- data.table(y$i > mean(y$i), y$j <= mean(y$j)) %??% q) |> str()
force(cond)
(v <- data.table::data.table(y$i > mean(y$i), y$j <= mean(y$j)) %??% q) |> str()
force(cond)
#
`%??%` <- function(cond, result){
#' Correlated IF-THEN-ELSE Comparison
#'
#' For each element \code{E} in \code{cond}, when \code{E} is \code{TRUE}, the corresponding index of \code{result$true} is returned: the same for \code{cond == FALSE}.
#' For \code{result}, the easiest way to set the available choices is to use \code{\link{\%tf\%}}; otherwise, a environment(-like) object with members named \code{true} and \code{false}
#'
#' @param cond (logical) A \emph{vector} or \emph{tensor} that evaluates to \code{TRUE} or \code{FALSE}
#' @param result (vector) Resultant values for TRUE and FALSE conditionals, ideally stored in a dimension-ed object (e.g, \code{\link[base]{data.frame}}, \code{\link[data.table]{data.table}})
#'
#' @family Custom operators
#'
#' @export
#'
return({ message("Function needs to be fixed: returning input as-is"); cond })
if (is.environment(result)){ result <- data.table::as.data.table(mget(c("true", "false"), envir = result)) }
if (!data.table::is.data.table(result)){ result <- data.table::as.data.table(result) }
purrr::map2(cond, purrr::array_branch(result, margin = 1), `%?%`) |> purrr::list_rbind()
}
(v <- data.table::data.table(y$i > mean(y$i), y$j <= mean(y$j)) %??% q) |> str()
# counters
sample(c(TRUE, FALSE), 50, TRUE) %>% count.cycles(reset = cumsum(.) %% 5 == 0)
# counters
sample(c(TRUE, FALSE), 50, TRUE) %>% print() |> count.cycles(reset = cumsum(.) %% 5 == 0)
# counters
sample(c(TRUE, FALSE), 50, TRUE) %>% print() %>% count.cycles(reset = cumsum(.) %% 5 == 0)
#
factor.int <- function(i, ...){
#' Factorization of Integers
#'
#' @param i (integer[]) One or more integers to factor
#' @param ... Additional integers to factor (can be used in conjunction with \code{i})
#'
#' @return The factors of the input given as an vector or list of vectors
#'
#' @family Counters
#'
#' @export
if (missing(i) & ...length() == 0){ message("[ERROR] Please supply integer values to either 'i' or '...'"); return(0); }
if (missing(i) & ...length() != 0){ i <- 0 }
i <- c(i, rlang::list2(...));
if (is.list(i)){ i <- unlist(i, use.names = FALSE) }
if (is.factor(i)){ i <- as.integer(i) }
if (is.character(i)){ i <- as.integer(i) }
if (is.numeric(i)){ i <- as.integer(i) }
i <- purrr::set_names(i);
.out <- outer(i, i, \(x, y) x %% y == 0); .out
# .out = purrr::map(i, ~{ .int = .x; purrr::keep(sequence(.int), ~.int %% .x == 0) });
# if (length(i) > 1){ distinct.list(.out[order(as.integer(names(.out)))]) } else { unlist(.out, use.names = FALSE) }
}
factor.int(10)
#
factor.int <- function(i, ...){
#' Factorization of Integers
#'
#' @param i (integer[]) One or more integers to factor
#' @param ... Additional integers to factor (can be used in conjunction with \code{i})
#'
#' @return The factors of the input given as an vector or list of vectors
#'
#' @family Counters
#'
#' @export
if (missing(i) & ...length() == 0){ message("[ERROR] Please supply integer values to either 'i' or '...'"); return(0); }
if (missing(i) & ...length() != 0){ i <- 0 }
i <- c(i, rlang::list2(...));
if (is.list(i)){ i <- unlist(i, use.names = FALSE) }
if (is.factor(i)){ i <- as.integer(i) }
if (is.character(i)){ i <- as.integer(i) }
if (is.numeric(i)){ i <- as.integer(i) }
i <- purrr::set_names(i);
.out <- outer(i, i, \(x, y) x %% y == 0);
diag(.out) <- 0
.out
# .out = purrr::map(i, ~{ .int = .x; purrr::keep(sequence(.int), ~.int %% .x == 0) });
# if (length(i) > 1){ distinct.list(.out[order(as.integer(names(.out)))]) } else { unlist(.out, use.names = FALSE) }
}
factor.int(100)
#
factor.int <- function(i, ...){
#' Factorization of Integers
#'
#' @param i (integer[]) One or more integers to factor
#' @param ... Additional integers to factor (can be used in conjunction with \code{i})
#'
#' @return The factors of the input given as an vector or list of vectors
#'
#' @family Counters
#'
#' @export
if (missing(i) & ...length() == 0){ message("[ERROR] Please supply integer values to either 'i' or '...'"); return(0); }
if (missing(i) & ...length() != 0){ i <- 0 }
i <- c(i, rlang::list2(...));
if (is.list(i)){ i <- unlist(i, use.names = FALSE) }
if (is.factor(i)){ i <- as.integer(i) }
if (is.character(i)){ i <- as.integer(i) }
if (is.numeric(i)){ i <- as.integer(i) }
i <- purrr::set_names(i);
.out <- outer(i, i, \(x, y) x %% sequence(y) == 0);
diag(.out) <- 0
.out
# .out = purrr::map(i, ~{ .int = .x; purrr::keep(sequence(.int), ~.int %% .x == 0) });
# if (length(i) > 1){ distinct.list(.out[order(as.integer(names(.out)))]) } else { unlist(.out, use.names = FALSE) }
}
factor.int(100)
#
factor.int <- function(i, ...){
#' Factorization of Integers
#'
#' @param i (integer[]) One or more integers to factor
#' @param ... Additional integers to factor (can be used in conjunction with \code{i})
#'
#' @return The factors of the input given as an vector or list of vectors
#'
#' @family Counters
#'
#' @export
if (missing(i) & ...length() == 0){ message("[ERROR] Please supply integer values to either 'i' or '...'"); return(0); }
if (missing(i) & ...length() != 0){ i <- 0 }
i <- c(i, rlang::list2(...));
if (is.list(i)){ i <- unlist(i, use.names = FALSE) }
if (is.factor(i)){ i <- as.integer(i) }
if (is.character(i)){ i <- as.integer(i) }
if (is.numeric(i)){ i <- as.integer(i) }
i <- purrr::set_names(i);
.out <- \(x) x %% sequence(x) == 0);
.out
# .out = purrr::map(i, ~{ .int = .x; purrr::keep(sequence(.int), ~.int %% .x == 0) });
# if (length(i) > 1){ distinct.list(.out[order(as.integer(names(.out)))]) } else { unlist(.out, use.names = FALSE) }
}
#
factor.int <- function(i, ...){
#' Factorization of Integers
#'
#' @param i (integer[]) One or more integers to factor
#' @param ... Additional integers to factor (can be used in conjunction with \code{i})
#'
#' @return The factors of the input given as an vector or list of vectors
#'
#' @family Counters
#'
#' @export
if (missing(i) & ...length() == 0){ message("[ERROR] Please supply integer values to either 'i' or '...'"); return(0); }
if (missing(i) & ...length() != 0){ i <- 0 }
i <- c(i, rlang::list2(...));
if (is.list(i)){ i <- unlist(i, use.names = FALSE) }
if (is.factor(i)){ i <- as.integer(i) }
if (is.character(i)){ i <- as.integer(i) }
if (is.numeric(i)){ i <- as.integer(i) }
i <- purrr::set_names(i);
.out <- \(x) x %% sequence(x) == 0;
.out
# .out = purrr::map(i, ~{ .int = .x; purrr::keep(sequence(.int), ~.int %% .x == 0) });
# if (length(i) > 1){ distinct.list(.out[order(as.integer(names(.out)))]) } else { unlist(.out, use.names = FALSE) }
}
factor.int(100)
#
factor.int <- function(i, ...){
#' Factorization of Integers
#'
#' @param i (integer[]) One or more integers to factor
#' @param ... Additional integers to factor (can be used in conjunction with \code{i})
#'
#' @return The factors of the input given as an vector or list of vectors
#'
#' @family Counters
#'
#' @export
if (missing(i) & ...length() == 0){ message("[ERROR] Please supply integer values to either 'i' or '...'"); return(0); }
if (missing(i) & ...length() != 0){ i <- 0 }
i <- c(i, rlang::list2(...));
if (is.list(i)){ i <- unlist(i, use.names = FALSE) }
if (is.factor(i)){ i <- as.integer(i) }
if (is.character(i)){ i <- as.integer(i) }
if (is.numeric(i)){ i <- as.integer(i) }
i <- purrr::set_names(i);
.out <- (\(x) x %% sequence(x) == 0)(i);
.out
# .out = purrr::map(i, ~{ .int = .x; purrr::keep(sequence(.int), ~.int %% .x == 0) });
# if (length(i) > 1){ distinct.list(.out[order(as.integer(names(.out)))]) } else { unlist(.out, use.names = FALSE) }
}
factor.int(100)
#
factor.int <- function(i, ...){
#' Factorization of Integers
#'
#' @param i (integer[]) One or more integers to factor
#' @param ... Additional integers to factor (can be used in conjunction with \code{i})
#'
#' @return The factors of the input given as an vector or list of vectors
#'
#' @family Counters
#'
#' @export
if (missing(i) & ...length() == 0){ message("[ERROR] Please supply integer values to either 'i' or '...'"); return(0); }
if (missing(i) & ...length() != 0){ i <- 0 }
i <- c(i, rlang::list2(...));
if (is.list(i)){ i <- unlist(i, use.names = FALSE) }
if (is.factor(i)){ i <- as.integer(i) }
if (is.character(i)){ i <- as.integer(i) }
if (is.numeric(i)){ i <- as.integer(i) }
i <- purrr::set_names(i);
.out <- purrr::map(i, \(x) which(x %% sequence(x) == 0))
if (rlang::has_length(.out, 1)){ .out[[1]] } else { .out }
# .out = purrr::map(i, ~{ .int = .x; purrr::keep(sequence(.int), ~.int %% .x == 0) });
# if (length(i) > 1){ distinct.list(.out[order(as.integer(names(.out)))]) } else { unlist(.out, use.names = FALSE) }
}
factor.int(100)
count.cycles <- function(cond, offset = 1, reset){
#' Cycle Counter
#'
#' \code{count.cycles} detects and maps conditional occurrence frequency
#'
#' @param cond (logical[]) A logical vector
#' @param offset (integer|1) An integer defining the series origin
#' @param reset (logical[]) A logical vector of the same length as \code{cond} such that when \code{TRUE}, the cycle counter resets to the offset
#'
#' @return A one-based (default), conditionally-incremented series
#'
#' @family Counters
#'
#' @export
# :: cycle_idx MUST be initialized before session() (see below) is called iteratively
offset = as.integer(offset)[1];
cycle_idx = offset;
# :: "counter()" is a function delegate and is the ESSENTIAL part of the routine
# Note how it is contained WITHIN this specific code block and is designed for conditional increment
# See http://adv-r.had.co.nz/Functional-programming.html, section "Mutable State"
count_idx = iterators::iter(1:length(cond));
# :: Define the counter function
counter = function(tf) {
idx = iterators::nextElem(count_idx);
if (tf) {
# cycle_idx only resets to the offset value when the limiter function returns 'TRUE'; otherwise, it increments
cycle_idx <<- cycle_idx + 1
}
# cycle_idx only resets to the offset value when the limiter function returns 'TRUE'; otherwise, it increments
cycle_idx <<- ifelse((idx %in% which(reset))|(idx == 1), offset, cycle_idx)
# return the current value of 'cycle_idx'
cycle_idx
}
# :: Call the counter function
sapply(cond, counter);
}
#
factor.int <- function(i, ...){
#' Factorization of Integers
#'
#' @param i (integer[]) One or more integers to factor
#' @param ... Additional integers to factor (can be used in conjunction with \code{i})
#'
#' @return The factors of the input given as an vector or list of vectors
#'
#' @family Counters
#'
#' @export
if (missing(i) & ...length() == 0){ message("[ERROR] Please supply integer values to either 'i' or '...'"); return(0); }
if (missing(i) & ...length() != 0){ i <- 0 }
i <- c(i, rlang::list2(...)) |> purrr::keep(is.numeric) |> round() |> as.integer();
i <- purrr::set_names(i);
.out <- purrr::map(i, \(x) which(x %% sequence(x) == 0))
if (rlang::has_length(.out, 1)){ .out[[1]] } else { .out }
# .out = purrr::map(i, ~{ .int = .x; purrr::keep(sequence(.int), ~.int %% .x == 0) });
# if (length(i) > 1){ distinct.list(.out[order(as.integer(names(.out)))]) } else { unlist(.out, use.names = FALSE) }
}
factor.int(100)
#
factor.int <- function(i, ...){
#' Factorization of Integers
#'
#' @param i (integer[]) One or more integers to factor
#' @param ... Additional integers to factor (can be used in conjunction with \code{i})
#'
#' @return The factors of the input given as an vector or list of vectors
#'
#' @family Counters
#'
#' @export
if (missing(i) & ...length() == 0){ message("[ERROR] Please supply integer values to either 'i' or '...'"); return(0); }
if (missing(i) & ...length() != 0){ i <- 0 }
i <- c(i, rlang::list2(...)) |> unlist() |> purrr::keep(is.numeric) |> round() |> as.integer();
i <- purrr::set_names(i);
.out <- purrr::map(i, \(x) which(x %% sequence(x) == 0))
if (rlang::has_length(.out, 1)){ .out[[1]] } else { .out }
# .out = purrr::map(i, ~{ .int = .x; purrr::keep(sequence(.int), ~.int %% .x == 0) });
# if (length(i) > 1){ distinct.list(.out[order(as.integer(names(.out)))]) } else { unlist(.out, use.names = FALSE) }
}
factor.int(100)
factor.int(100, 90)
library(book.of.utilities)
library(book.of.utilities)
pkgdown::build_site(pkg = "pkg", lazy = TRUE, override = list(destination = "../docs"))
library(magick)
img <- magick::image_read("../img/book.png")
getwd()
img <- magick::image_read("img/book.png")
img_small <- magick::image_resize(image = img, geometry = geometry_size_percent(5))
magick::image_write(img_small, path = "img/book_small.png", format = ".png")
magick::image_write(img_small, path = "img/book_small.png", format = "png")
getwd()
git_dir <- paste0(getwd(), "/..")
dir(git_dir)
dir(git_dir, pattern = "arch|book|DB|event|smart|remote")
dir(git_dir, pattern = "arch|book|DB|event|smart|remote", full.names = TRUE)
dir(git_dir, pattern = "img$", full.names = TRUE, include.dirs = TRUE, recursive = TRUE)
pkgdown::build_site(pkg = "pkg", lazy = TRUE, override = list(destination = "../docs"))
install.packages("pkgdown", lib="C:/Program Files/R/R-4.1.3/library")
pkgdown::build_site(pkg = "pkg", lazy = TRUE, override = list(destination = "../docs"))
pkgdown::build_site(pkg = "pkg", lazy = TRUE, override = list(destination = "../docs"))
