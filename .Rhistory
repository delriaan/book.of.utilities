#
factor.int <- function(i, ...){
#' Factorization of Integers
#'
#' @param i (integer[]) One or more integers to factor
#' @param ... Additional integers to factor (can be used in conjunction with \code{i})
#'
#' @return The factors of the input given as an vector or list of vectors
#'
#' @family Counters
#'
#' @export
if (missing(i) & ...length() == 0){ message("[ERROR] Please supply integer values to either 'i' or '...'"); return(0); }
if (missing(i) & ...length() != 0){ i <- 0 }
i <- c(i, rlang::list2(...));
if (is.list(i)){ i <- unlist(i, use.names = FALSE) }
if (is.factor(i)){ i <- as.integer(i) }
if (is.character(i)){ i <- as.integer(i) }
if (is.numeric(i)){ i <- as.integer(i) }
i <- purrr::set_names(i);
.out = purrr::map(i, ~{ .int = .x; purrr::keep(sequence(.int), ~.int %% .x == 0) });
if (length(i) > 1){ distinct.list(.out[order(as.integer(names(.out)))]) } else { unlist(.out, use.names = FALSE) }
}
distinct.list <- function(i, logical.only = FALSE){
#' Unique List Selection
#'
#' Return the distinct set of first-level list elements based on their respective base64-encoded signatures.  This is an inefficient implementation used for nested lists
#'
#' @param i (object) The input list object (or coercible)
#' @param logical.only (logical) When \code{TRUE}, a logical vector is returned
#'
#' @return The list with unique, first-level child elements
#' @family List management
#'
#' @family Object management
#'
# @export
i = if (any(class(i) %in% c("data.table", "data.frame", "tibble"))){ as.list(i) } else { i }
x <- slider::slide(.x = i, .step = 1, .f = purrr::as_mapper(~sodium::hash(serialize(.x), size = 24))) |> duplicated() |> magrittr::not()
if (logical.only){ x } else { i[x] }
}
factor.int(30)
factor.int(19)
factor.int(92)
library(book.of.utilities)
getwd()
library(book.of.utilities)
# as.recursive() ====
fun <- as.recursive(
fun = function(...){
sample(rlang::list2(...) |> unlist() |> as.vector(), size = 10, replace = TRUE)
}
, cond_def = ~mean(.) <= median(.)
, finalize = ~list(x = rlang::set_names(., seq_along(.)), y = reduce(., ~mean(c(.x, .x + .y), na.rm = TRUE)))
)
(inspect <- fun(!!!c(1:100)))
# Build Site ----
# usethis::use_pkgdown()
pkgdown::build_site(pkg = "pkg", lazy = TRUE, override = list(destination = "../docs"))
library(book.of.utilities)
# Build Site ----
# usethis::use_pkgdown()
pkgdown::build_site(pkg = "pkg", lazy = TRUE, override = list(destination = "../docs"))
install.packages("slider")
install.packages("slider", lib="C:/Program Files/R/R-4.1.3/library")
library(book.of.utilities)
install.packages("roxygen2", lib="C:/Program Files/R/R-4.1.3/library")
install.packages("rlang")
install.packages("roxygen2", lib="C:/Program Files/R/R-4.1.3/library")
install.packages("rlang", lib="C:/Program Files/R/R-4.1.3/library")
library(book.of.utilities)
keyring::keyring_list()
which(keyring::keyring_list()$keyring != "")
keyring::keyring_list()[1, ]
which(keyring::keyring_list()$keyring %in% keyring) %||% which(keyring::keyring_list()$keyring != "")
keyring = NULL
which(keyring::keyring_list()$keyring %in% keyring) %||% which(keyring::keyring_list()$keyring != "")
keyring::keyring_list()$keyring %in% keyring
if (rlang::is_empty(keyring)){
which(keyring::keyring_list()$keyring != "")
} else {
which(keyring::keyring_list()$keyring %in% keyring) %||% which(keyring::keyring_list()$keyring != "")
}
keyring_export <- function(keyring = NULL){
kr_idx <- if (rlang::is_empty(keyring)){
which(keyring::keyring_list()$keyring != "")
} else {
which(keyring::keyring_list()$keyring %in% keyring) %||% which(keyring::keyring_list()$keyring != "")
}
keyring::keyring_list()[kr_idx, ] |>
purrr::modify_at(3, as.logical) |>
purrr::modify_at(2, as.integer) |>
purrr::pmap(~{
kr <- ..1;
if (..3){ keyring::keyring_unlock(keyring = ..1) }
f <- purrr::as_mapper(~{
rlang::inject(
c(!!!.x
, value = keyring::key_get(!!!purrr::discard(.x, ~.x == ""), keyring = kr)
)
})
rlang::list2(!!kr := key_list(keyring = kr) |>
apply(1, f, simplify = TRUE) |> t() |>
as.data.frame() |>
jsonlite::toJSON("columns"))
}) |>
purrr::flatten()
}
keyring_export(keyring = "R")
keyring_export <- function(keyring = NULL){
kr_idx <- if (rlang::is_empty(keyring)){
which(keyring::keyring_list()$keyring != "")
} else {
which(keyring::keyring_list()$keyring %in% keyring) %||% which(keyring::keyring_list()$keyring != "")
}
keyring::keyring_list()[kr_idx, ] |>
purrr::modify_at(3, as.logical) |>
purrr::modify_at(2, as.integer) |>
purrr::pmap(~{
kr <- ..1;
if (..3){ keyring::keyring_unlock(keyring = ..1) }
f <- purrr::as_mapper(~{
rlang::inject(
c(!!!.x
, value = keyring::key_get(!!!purrr::discard(.x, ~.x == ""), keyring = kr)
)
})
rlang::list2(!!kr := keyring::key_list(keyring = kr) |>
apply(1, f, simplify = TRUE) |> t() |>
as.data.frame() |>
jsonlite::toJSON("columns"))
}) |>
purrr::flatten()
}
keyring_export(keyring = "R")
keyring_export <- function(keyring = NULL, as.raw = FALSE){
#' Export keyring Entries
#'
#' \code{keyring_export} creates JSON output for available \code{\link[keyring]{keyring}}s
#'
#' @param keyring (string[]) The name(s) of keyrings to export (defaults to all named keyrings when calling \code{\link[keyring]{keyring_list}})
#' @param as.raw (logical | FALSE) Should each entry be cast as a raw vector?
#'
#' @return Keyring entries as JSON or raw-encoded JSON
#'
#' @export
kr_idx <- if (rlang::is_empty(keyring)){
which(keyring::keyring_list()$keyring != "")
} else {
which(keyring::keyring_list()$keyring %in% keyring) %||% which(keyring::keyring_list()$keyring != "")
}
keyring::keyring_list()[kr_idx, ] |>
purrr::modify_at(3, as.logical) |>
purrr::modify_at(2, as.integer) |>
purrr::pmap(~{
kr <- ..1;
if (..3){ keyring::keyring_unlock(keyring = ..1) }
f <- purrr::as_mapper(~{
rlang::inject(
c(!!!.x
, value = keyring::key_get(!!!purrr::discard(.x, ~.x == ""), keyring = kr)
)
})
.out <- rlang::list2(!!kr := keyring::key_list(keyring = kr) |>
apply(1, f, simplify = TRUE) |> t() |>
as.data.frame() |>
jsonlite::toJSON("columns"))
if (as.raw){ purrr::modify_at(.out, kr, charToRaw) } else { .out }
}) |>
purrr::flatten()
}
keyring_export(keyring = "R")
keyring_export(keyring = "R", TRUE)
keyring_import <- function(...){
rlang::list2(...) |>
purrr::imap(~{
{ if (is.raw(.x)){ rawToChar(.x) } else { .x }} |> jsonlite::fromJSON()
})
}
keyring_export(keyring = "R", TRUE) |> keyring_import()
keyring_import <- function(...){
rlang::list2(...) |>
purrr::imap(~{
keyring <- .y
kr_data <- if (is.raw(.x)){ rawToChar(.x) } else { .x }
jsonlite::fromJSON(kr_data)
})
}
keyring_import <- function(data, ...){
rlang::list2(data, ...) |>
purrr::imap(~{
keyring <- .y
kr_data <- if (is.raw(.x)){ rawToChar(.x) } else { .x }
jsonlite::fromJSON(kr_data)
})
}
keyring_export(keyring = "R", TRUE) |> keyring_import()
debug(keyring_import)
keyring_export(keyring = "R", TRUE) |> keyring_import()
keyring_import <- function(data, ...){
c(data, rlang::list2(...)) |>
purrr::imap(~{
keyring <- .y
kr_data <- if (is.raw(.x)){ rawToChar(.x) } else { .x }
jsonlite::fromJSON(kr_data)
})
}
keyring_export(keyring = "R", TRUE) |> keyring_import()
keyring_import <- function(data, ...){
c(data, rlang::list2(...)) |>
purrr::imap(~{
keyring <- .y
kr_data <- if (is.raw(.x)){ rawToChar(.x) } else { .x }
jsonlite::fromJSON(kr_data) |>
data.table::transpose()
})
}
keyring_export(keyring = "R", TRUE) |> keyring_import()
View(.Last.value)
keyring_import <- function(data, ...){
c(data, rlang::list2(...)) |>
purrr::imap(~{
keyring <- .y
kr_data <- if (is.raw(.x)){ rawToChar(.x) } else { .x }
jsonlite::fromJSON(kr_data)
})
}
keyring_export(keyring = "R", TRUE) |> keyring_import()
keyring_import <- function(data, ...){
c(data, rlang::list2(...)) |>
purrr::imap(~{
keyring <- .y
kr_data <- if (is.raw(.x)){ rawToChar(.x) } else { .x }
jsonlite::fromJSON(kr_data) |>
purrr::pmap(~{
keyring::key_set_with_value(service = !!..1, username = !!..2, password = !!..3, keyring = !!keyring)
})
}
keyring_export(keyring = "R", TRUE) |> keyring_import()
keyring_import <- function(data, ...){
c(data, rlang::list2(...)) |>
purrr::imap(~{
keyring <- .y
kr_data <- if (is.raw(.x)){ rawToChar(.x) } else { .x }
jsonlite::fromJSON(kr_data) |>
purrr::pmap(~{
rlang::expr(
keyring::key_set_with_value(service = !!..1, username = !!..2, password = !!..3, keyring = !!keyring)
)
})
}
keyring_export(keyring = "R", TRUE) |> keyring_import()
purrr::imap(c(1, b = 4), ~class(.y))
purrr::imap(c(1, b = 4), ~rlang::is_empty(.y))
purrr::imap(c(1, b = 4), ~str(.y))
which(names(1:10) == "") |> paste(collapse = ",")
which(names(1:10) == "") #|> paste(collapse = ",")
paste(1, collapse = ",")
paste(c(1, 4), collapse = ",")
keyring_import <- function(data, ...){
#' Import keyring Entries
#'
#' \code{keyring_import} registers exported \code{\link[keyring]{keyring}}s (see \code{\link{keyring_export}})
#'
#' @param data The named list of exported keyring data
#' @param ... Additional named keyring entries
#' @param as.raw (logical | FALSE) Should each entry be cast as a raw vector?
#'
#' @note Unnamed inputs will not be imported but indicated via console message
#'
#' @return Keyring entries as JSON or raw-encoded JSON
#' @family keyring Utilities
#' @export
data <- append(data, rlang::list2(...));
no.names <- which(names(data) == "")
if (!identical(integer(), no.names)){
message(sprintf("Entries at the following positions will not be imported: %s", paste(no.names, collapse = ", ")))
}
data <- data[-no.names];
if (rlang::is_empty(data)){
message("No action taken (all entries are unnamed): exiting ..."); return()
}
purrr::iwalk(data, ~{
keyring <- .y
kr_data <- if (is.raw(.x)){ rawToChar(.x) } else { .x }
jsonlite::fromJSON(kr_data) |>
purrr::pwalk(~{
keyring::key_set_with_value(
service 		= ..1
, username	= ..2
, password	= ..3
, keyring 	= keyring
)
})
}
keyring_export(keyring = "R", TRUE) |> keyring_import(c(3))
keyring_export(keyring = "R", TRUE)
keyring_export(keyring = "R", !TRUE)
library(book.of.utilities)
