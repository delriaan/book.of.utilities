#
factor.int <- function(i, ...){
#' Factorization of Integers
#'
#' @param i (integer[]) One or more integers to factor
#' @param ... Additional integers to factor (can be used in conjunction with \code{i})
#'
#' @return The factors of the input given as an vector or list of vectors
#'
#' @family Counters
#'
#' @export
if (missing(i) & ...length() == 0){ message("[ERROR] Please supply integer values to either 'i' or '...'"); return(0); }
if (missing(i) & ...length() != 0){ i <- 0 }
i <- c(i, rlang::list2(...));
if (is.list(i)){ i <- unlist(i, use.names = FALSE) }
if (is.factor(i)){ i <- as.integer(i) }
if (is.character(i)){ i <- as.integer(i) }
if (is.numeric(i)){ i <- as.integer(i) }
i <- purrr::set_names(i);
.out = purrr::map(i, ~{ .int = .x; purrr::keep(sequence(.int), ~.int %% .x == 0) });
if (length(i) > 1){ distinct.list(.out[order(as.integer(names(.out)))]) } else { unlist(.out, use.names = FALSE) }
}
distinct.list <- function(i, logical.only = FALSE){
#' Unique List Selection
#'
#' Return the distinct set of first-level list elements based on their respective base64-encoded signatures.  This is an inefficient implementation used for nested lists
#'
#' @param i (object) The input list object (or coercible)
#' @param logical.only (logical) When \code{TRUE}, a logical vector is returned
#'
#' @return The list with unique, first-level child elements
#' @family List management
#'
#' @family Object management
#'
# @export
i = if (any(class(i) %in% c("data.table", "data.frame", "tibble"))){ as.list(i) } else { i }
x <- slider::slide(.x = i, .step = 1, .f = purrr::as_mapper(~sodium::hash(serialize(.x), size = 24))) |> duplicated() |> magrittr::not()
if (logical.only){ x } else { i[x] }
}
factor.int(30)
factor.int(19)
factor.int(92)
library(book.of.utilities)
getwd()
library(book.of.utilities)
# as.recursive() ====
fun <- as.recursive(
fun = function(...){
sample(rlang::list2(...) |> unlist() |> as.vector(), size = 10, replace = TRUE)
}
, cond_def = ~mean(.) <= median(.)
, finalize = ~list(x = rlang::set_names(., seq_along(.)), y = reduce(., ~mean(c(.x, .x + .y), na.rm = TRUE)))
)
(inspect <- fun(!!!c(1:100)))
# Build Site ----
# usethis::use_pkgdown()
pkgdown::build_site(pkg = "pkg", lazy = TRUE, override = list(destination = "../docs"))
library(book.of.utilities)
# Build Site ----
# usethis::use_pkgdown()
pkgdown::build_site(pkg = "pkg", lazy = TRUE, override = list(destination = "../docs"))
library(book.of.utilities)
