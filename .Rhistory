ord.i <- order(.i)
.i <- sort(.i)
.i <-  cumsum(.i)/sum(.i, na.rm = TRUE)
.i[ord.i]
}
of.max <- \(.i) .i/max(.i, na.rm = TRUE)
of.min <- \(.i) .i/min(.i[i > 0], na.rm = TRUE)
of.sum <- \(.i) .i/sum(.i, na.rm = TRUE)
.out <- if (rlang::has_length(type, 1)){
do.call(type, args = list(.i = i)) |> round(decimals)
} else {
purrr::set_names(type) %>% purrr::map(\(k) do.call(k, args = list(.i = i)) |> round(decimals))
}
if (as_density){
.prop <- cumulative(sapply(.out, \(x) sum(x <= .out)))
.out <- .out * .prop * (1 - .prop)
}
return (.out)
}
ratio(x, type = "cumulative")
ratio(x, type = "pareto")
ratio(x, type = "pareto", as_density = FALSE)
ratio(x, type = "pareto", as_density = TRUE)
ratio(x, type = "pareto", as_density = FALSE) %>% plot(x = x[order(.)], y = ., col = "blue")
ratio(x, type = "pareto", as_density = TRUE)  |> sort()|> plot(x = sort(x), col = "red")
ratio(x, type = "pareto", as_density = TRUE)
ratio(x, type = "pareto", as_density = FALSE)
ratio(x, type = "pareto", as_density = FALSE) %>% plot(x = x[order(.)], y = sort(.), col = "blue")
ratio(x, type = "pareto", as_density = FALSE) %>% { plot(x = x[order(.)], y = sort(.), col = "blue") }
ratio(x, type = "pareto", as_density = !FALSE) %>% { plot(x = x[order(.)], y = sort(.), col = "red") }
ratio(x, type = "pareto", as_density = FALSE)
ratio(x, type = "pareto", as_density = FALSE) %>% { plot(x = x[order(.)], y = sort(.), col = "blue") }
ratio(x, type = "pareto", as_density = FALSE) |> sort()
#
ratio <- function(i, type = "of.sum", decimals = 2, as_density = FALSE, base = exp(1)){
#' Ratio Calculator
#'
#' \code{ratio} calculates one of the following ratio types:\cr
#' \enumerate{
#' \item{\code{"of.sum"} (relative to the sum of \code{i})}
#' \item{\code{"of.max|of.min"} (relative to maximum/minimum value)}
#' \item{\code{"cumulative"} (cumulative total vs. total)}
#' }.\cr Using the related operator \code{\%ratio\%} assumes simple division by the total of \code{i}.
#'
#' @param i (vector) numeric vector
#' @param type (string[]) The types of ratio algorithms to use (see Details): a vector of supported values is supported
#' @param decimals (integer | 2) The number of decimal places to which the output should be rounded
#' @param as_density (logical) \code{TRUE} returns \code{x * p(1 - p)}, where \code{p} is a vector of proportions of \code{x} <= each value in \code{x}
#' @param base (numeric) The base to use for \emph{softmax} scaling
#'
#' @note Because this function produces values on a \emph{ratio} scale, all values are shifted such that all values are >= 0.
#'
#' @family Chapter 1 - Calculators
#'
#' @export
# Handle legacy code ...
if (type == "pareto"){ type <- "cumulative" }
i <- (\(x){
if (any(x < 0)){
ord.x <- order(x)
x <- sort(x)
x <- abs(min(x)) + c(0, diff(x))
x[ord.x]
} else { x }
})(i)
# Functions selected by 'type'
cumulative <- \(.i){
ord.i <- order(.i)
.i <- sort(.i)
.i <-  cumsum(.i)/sum(.i, na.rm = TRUE)
.i[ord.i]
}
of.max <- \(.i) .i/max(.i, na.rm = TRUE)
of.min <- \(.i) .i/min(.i[i > 0], na.rm = TRUE)
of.sum <- \(.i) .i/sum(.i, na.rm = TRUE)
.out <- if (rlang::has_length(type, 1)){
do.call(type, args = list(.i = i)) |> round(decimals)
} else {
purrr::set_names(type) %>% purrr::map(\(k) do.call(k, args = list(.i = i)) |> round(decimals))
}
if (as_density){
if (type == "cumulative"){
.out <- .out * (1 - .out)
} else {
.prop <- cumulative(.out)
.out <- .out * .prop * (1 - .prop)
}
return (.out)
}
ratio(x)
ratio(x, type = "of.min")
ratio(x, type = "of.max")
ratio(x, type = "cumulative")
ratio(x, type = "pareto")
ratio(x, type = "pareto", as_density = FALSE) |> sort()
ratio(x, type = "pareto", as_density = FALSE) %>% { plot(x = x[order(.)], y = sort(.), col = "blue") }
ratio(x, type = "pareto", as_density = TRUE)
ratio(x, type = "pareto", as_density = FALSE) %>% { plot(x = x[order(.)], y = ., col = "blue") }
ratio(x, type = "pareto", as_density = FALSE) %>% { plot(x = x, y = ., col = "blue") }
ratio(x, type = "pareto", as_density = FALSE) %>% { plot(x = abs(x), y = ., col = "blue") }
ratio(x, type = "pareto", as_density = FALSE) %>% { plot(x = abs(x)[order(.)], y = ., col = "blue") }
ratio(x, type = "pareto", as_density = !FALSE) %>% { plot(x = abs(x)[order(.)], y = ., col = "red") }
#
ratio <- function(i, type = "of.sum", decimals = 2, as_density = FALSE, base = exp(1)){
#' Ratio Calculator
#'
#' \code{ratio} calculates one of the following ratio types:\cr
#' \enumerate{
#' \item{\code{"of.sum"} (relative to the sum of \code{i})}
#' \item{\code{"of.max|of.min"} (relative to maximum/minimum value)}
#' \item{\code{"cumulative"} (cumulative total vs. total)}
#' }.\cr Using the related operator \code{\%ratio\%} assumes simple division by the total of \code{i}.
#'
#' @param i (vector) numeric vector
#' @param type (string[]) The types of ratio algorithms to use (see Details): a vector of supported values is supported
#' @param decimals (integer | 2) The number of decimal places to which the output should be rounded
#' @param as_density (logical) \code{TRUE} returns \code{x * p(1 - p)}, where \code{p} is a vector of proportions of \code{x} <= each value in \code{x}
#' @param base (numeric) The base to use for \emph{softmax} scaling
#'
#' @note Because this function produces values on a \emph{ratio} scale, all values are shifted such that all values are >= 0.
#'
#' @family Chapter 1 - Calculators
#'
#' @export
# Handle legacy code ...
if (type == "pareto"){ type <- "cumulative" }
ord.i <- order(i);
i <- sort(i);
if (any(i < 0)){ i <- abs(min(i)) + c(0, diff(i)) }
# Functions selected by 'type'
cumulative <- \(.i) cumsum(.i)/sum(.i, na.rm = TRUE)
of.max <- \(.i) .i/max(.i, na.rm = TRUE)
of.min <- \(.i) .i/min(.i[i > 0], na.rm = TRUE)
of.sum <- \(.i) .i/sum(.i, na.rm = TRUE)
.out <- if (rlang::has_length(type, 1)){
do.call(type, args = list(.i = i)) |> round(decimals)
} else {
purrr::set_names(type) %>% purrr::map(\(k) do.call(k, args = list(.i = i)) |> round(decimals))
}
if (as_density){
if (type == "cumulative"){
.out <- .out * (1 - .out)
} else {
.prop <- cumulative(.out)
.out <- .out * .prop * (1 - .prop)
}
return (.out[ord.i])
}
ratio(x)
ratio(x, type = "of.min")
ratio(x, type = "of.max")
ratio(x, type = "cumulative")
ratio(x, type = "pareto")
ratio(x, type = "pareto", as_density = FALSE)
ratio(x, type = "pareto", as_density = FALSE) %>% { plot(x = x, y = ., col = "blue") }
ratio(x, type = "pareto", as_density = !FALSE) %>% { plot(x = x, y = ., col = "red") }
ratio(x, type = "cumulative", as_density = TRUE)
data.frame(x = x, y = ratio(x, type = "cumulative", as_density = TRUE))
data.frame(x = x, y = ratio(x))
data.frame(x = x, y = ratio(x, type = "of.min"))
data.frame(x = x, y = ratio(x, type = "of.max"))
data.frame(x = x, y = ratio(x, type = "cumulative"))
data.frame(x = x, y = ratio(x, type = "pareto"))
data.frame(x = x, y = ratio(x, type = "cumulative")) |> View()
data.frame(x = x, y = ratio(x, type = "pareto"))
debug(ratio)
data.frame(x = x, y = ratio(x, type = "pareto"))
i
.out
.out[ord.i]
i[ord.i]
#
ratio <- function(i, type = "of.sum", decimals = 2, as_density = FALSE, base = exp(1)){
#' Ratio Calculator
#'
#' \code{ratio} calculates one of the following ratio types:\cr
#' \enumerate{
#' \item{\code{"of.sum"} (relative to the sum of \code{i})}
#' \item{\code{"of.max|of.min"} (relative to maximum/minimum value)}
#' \item{\code{"cumulative"} (cumulative total vs. total)}
#' }.\cr Using the related operator \code{\%ratio\%} assumes simple division by the total of \code{i}.
#'
#' @param i (vector) numeric vector
#' @param type (string[]) The types of ratio algorithms to use (see Details): a vector of supported values is supported
#' @param decimals (integer | 2) The number of decimal places to which the output should be rounded
#' @param as_density (logical) \code{TRUE} returns \code{x * p(1 - p)}, where \code{p} is a vector of proportions of \code{x} <= each value in \code{x}
#' @param base (numeric) The base to use for \emph{softmax} scaling
#'
#' @note Because this function produces values on a \emph{ratio} scale, all values are shifted such that all values are >= 0.
#'
#' @family Chapter 1 - Calculators
#'
#' @export
# Handle legacy code ...
if (type == "pareto"){ type <- "cumulative" }
ord.i <- order(i);
i <- sort(i);
if (any(i < 0)){ i <- abs(min(i)) + c(0, diff(i)) }
# Functions selected by 'type'
cumulative <- \(.i) cumsum(.i)/sum(.i, na.rm = TRUE);
of.max <- \(.i) .i/max(.i, na.rm = TRUE);
of.min <- \(.i) .i/min(.i[i > 0], na.rm = TRUE);
of.sum <- \(.i) .i/sum(.i, na.rm = TRUE);
.out <- if (rlang::has_length(type, 1)){
do.call(type, args = list(.i = i)) |> round(decimals)
} else {
purrr::set_names(type) %>% purrr::map(\(k) do.call(k, args = list(.i = i)) |> round(decimals))
}
if (as_density){
if (type == "cumulative"){
.out <- .out * (1 - .out)
} else {
.prop <- outer(.out, .out, `<=`) |> colMeans(na.rm = TRUE)
.out <- .out * .prop * (1 - .prop)
}
return (.out[ord.i])
}
data.frame(x = x, y = ratio(x, type = "pareto"))
data.frame(x = x, y = ratio(x, type = "cumulative"))
data.frame(x = x, y = ratio(x, type = "cumulative", as_density = TRUE))
data.frame(x = x, y = ratio(x, type = "cumulative", as_density = TRUE)) |> View()
#
ratio <- function(i, type = "of.sum", decimals = 2, as_density = FALSE, base = exp(1)){
#' Ratio Calculator
#'
#' \code{ratio} calculates one of the following ratio types:\cr
#' \enumerate{
#' \item{\code{"of.sum"} (relative to the sum of \code{i})}
#' \item{\code{"of.max|of.min"} (relative to maximum/minimum value)}
#' \item{\code{"cumulative"} (cumulative total vs. total)}
#' }.\cr Using the related operator \code{\%ratio\%} assumes simple division by the total of \code{i}.
#'
#' @param i (vector) numeric vector
#' @param type (string[]) The types of ratio algorithms to use (see Details): a vector of supported values is supported
#' @param decimals (integer | 2) The number of decimal places to which the output should be rounded
#' @param as_density (logical) \code{TRUE} returns \code{x * p(1 - p)}, where \code{p} is a vector of proportions of \code{x} <= each value in \code{x}
#' @param base (numeric) The base to use for \emph{softmax} scaling
#'
#' @note Because this function produces values on a \emph{ratio} scale, all values are shifted such that all values are >= 0.
#'
#' @family Chapter 1 - Calculators
#'
#' @export
# Handle legacy code ...
if (type == "pareto"){ type <- "cumulative" }
ord.i <- base::order(i);
i <- sort(i);
if (any(i < 0)){ i <- abs(min(i)) + c(0, diff(i)) }
# Functions selected by 'type'
cumulative <- \(.i) cumsum(.i)/sum(.i, na.rm = TRUE);
of.max <- \(.i) .i/max(.i, na.rm = TRUE);
of.min <- \(.i) .i/min(.i[i > 0], na.rm = TRUE);
of.sum <- \(.i) .i/sum(.i, na.rm = TRUE);
.out <- if (rlang::has_length(type, 1)){
do.call(type, args = list(.i = i)) |> round(decimals)
} else {
purrr::set_names(type) %>% purrr::map(\(k) do.call(k, args = list(.i = i)) |> round(decimals))
}
if (as_density){
if (type == "cumulative"){
.out <- .out * (1 - .out)
} else {
.prop <- outer(.out, .out, `<=`) |> colMeans(na.rm = TRUE)
.out <- .out * .prop * (1 - .prop)
}
return (.out[ord.i])
}
# ratio ----
x <- sample(-100:100, 30)
# debug(ratio)
data.frame(x = x, y = ratio(x))
#
ratio <- function(i, type = "of.sum", decimals = 2, as_density = FALSE, base = exp(1)){
#' Ratio Calculator
#'
#' \code{ratio} calculates one of the following ratio types:\cr
#' \enumerate{
#' \item{\code{"of.sum"} (relative to the sum of \code{i})}
#' \item{\code{"of.max"} (relative to maximum value)}
#' \item{\code{"cumulative"} (cumulative total vs. total)}
#' }.\cr Using the related operator \code{\%ratio\%} assumes simple division by the total of \code{i}.
#'
#' @param i (vector) numeric vector
#' @param type (string[]) The types of ratio algorithms to use (see Details): a vector of supported values is supported
#' @param decimals (integer | 2) The number of decimal places to which the output should be rounded
#' @param as_density (logical) \code{TRUE} returns \code{x * p(1 - p)}, where \code{p} is a vector of proportions of \code{x} <= each value in \code{x}
#' @param base (numeric) The base to use for \emph{softmax} scaling
#'
#' @note Because this function produces values on a \emph{ratio} scale, all values are shifted such that all values are >= 0.
#'
#' @family Chapter 1 - Calculators
#'
#' @export
# Handle legacy code ...
if (type == "pareto"){ type <- "cumulative" }
ord.i <- base::order(i);
i <- sort(i);
if (any(i < 0)){ i <- i + abs(min(i)) }
# Functions selected by 'type'
cumulative <- \(.i) cumsum(.i)/sum(.i, na.rm = TRUE);
of.max <- \(.i) .i/max(.i, na.rm = TRUE);
of.sum <- \(.i) .i/sum(.i, na.rm = TRUE);
.out <- if (rlang::has_length(type, 1)){
do.call(type, args = list(.i = i)) |> round(decimals)
} else {
purrr::set_names(type) %>% purrr::map(\(k) do.call(k, args = list(.i = i)) |> round(decimals))
}
if (as_density){
if (type == "cumulative"){
.out <- .out * (1 - .out)
} else {
.prop <- outer(.out, .out, `<=`) |> colMeans(na.rm = TRUE)
.out <- .out * .prop * (1 - .prop)
}
return (.out[ord.i])
}
# debug(ratio)
data.frame(x = x, y = ratio(x))
# debug(ratio)
data.table::data.table(y = ratio(x), key = "y")[, x := x[order(y)]]
# debug(ratio)
data.table::data.table(y = ratio(x), key = "y")[, x := x[order(y)]] |> print()
# debug(ratio)
(data.table::data.table(y = ratio(x), key = "y")[, x := x[order(y)]])
# debug(ratio)
data.table::data.table(y = ratio(x), key = "y")[, x := x[order(y)]] |> View()
# ratio ----
x <- sample(-100:100, 30)
# ratio ----
(x <- sample(-100:100, 30))
ratio(x, type = "cumulative")
debug(ratio)
ratio(x, type = "cumulative")
orig.i <- i
i[ord.i]
orig.i
orig.i[ord.i]
ord.i
rank(orig.i)
#
ratio <- function(i, type = "of.sum", decimals = 2, as_density = FALSE, base = exp(1)){
#' Ratio Calculator
#'
#' \code{ratio} calculates one of the following ratio types:\cr
#' \enumerate{
#' \item{\code{"of.sum"} (relative to the sum of \code{i})}
#' \item{\code{"of.max"} (relative to maximum value)}
#' \item{\code{"cumulative"} (cumulative total vs. total)}
#' }.\cr Using the related operator \code{\%ratio\%} assumes simple division by the total of \code{i}.
#'
#' @param i (vector) numeric vector
#' @param type (string[]) The types of ratio algorithms to use (see Details): a vector of supported values is supported
#' @param decimals (integer | 2) The number of decimal places to which the output should be rounded
#' @param as_density (logical) \code{TRUE} returns \code{x * p(1 - p)}, where \code{p} is a vector of proportions of \code{x} <= each value in \code{x}
#' @param base (numeric) The base to use for \emph{softmax} scaling
#'
#' @note Because this function produces values on a \emph{ratio} scale, all values are shifted such that all values are >= 0.
#'
#' @family Chapter 1 - Calculators
#'
#' @export
# Handle legacy code ...
if (type == "pareto"){ type <- "cumulative" }
ord.i <- base::rank(i, ties.method = "last", na.last = TRUE);
i <- sort(i);
if (any(i < 0)){ i <- i + abs(min(i)) }
# Functions selected by 'type'
cumulative <- \(.i) cumsum(.i)/sum(.i, na.rm = TRUE);
of.max <- \(.i) .i/max(.i, na.rm = TRUE);
of.sum <- \(.i) .i/sum(.i, na.rm = TRUE);
.out <- if (rlang::has_length(type, 1)){
do.call(type, args = list(.i = i)) |> round(decimals)
} else {
purrr::set_names(type) %>% purrr::map(\(k) do.call(k, args = list(.i = i)) |> round(decimals))
}
if (as_density){
if (type == "cumulative"){
.out <- .out * (1 - .out)
} else {
.prop <- outer(.out, .out, `<=`) |> colMeans(na.rm = TRUE)
.out <- .out * .prop * (1 - .prop)
}
return (.out[ord.i])
}
# debug(ratio)
data.frame(x = x, y = ratio(x))
data.frame(x = x, y = ratio(x, type = "of.max"))
data.frame(x = x, y = ratio(x, type = "pareto"))
data.frame(x = x, y = ratio(x, type = "cumulative"))
ratio(x, type = "pareto", as_density = FALSE)
ratio(x, type = "pareto", as_density = FALSE) %>% { plot(x = x, y = ., col = "blue") }
ratio(x, type = "pareto", as_density = !FALSE) %>% { plot(x = abs(x)[order(.)], y = ., col = "red") }
ratio(x, type = "pareto", as_density = TRUE) %>% { plot(x = x, y = ., col = "red") }
ratio(x, type = "of.max", as_density = TRUE)
ratio(x, type = "of.max", as_density = TRUE, base = 10) |> plot()
#
ratio <- function(i, type = "of.sum", decimals = 2, as_density = FALSE, base = exp(1)){
#' Ratio Calculator
#'
#' \code{ratio} calculates one of the following ratio types:\cr
#' \enumerate{
#' \item{\code{"of.sum"} (relative to the sum of \code{i})}
#' \item{\code{"of.max"} (relative to maximum value)}
#' \item{\code{"cumulative"} (cumulative total vs. total)}
#' }.\cr Using the related operator \code{\%ratio\%} assumes simple division by the total of \code{i}.
#'
#' @param i (vector) numeric vector
#' @param type (string[]) The types of ratio algorithms to use (see Details): a vector of supported values is supported
#' @param decimals (integer | 2) The number of decimal places to which the output should be rounded
#' @param as_density (logical) \code{TRUE} returns \code{x * p(1 - p)}, where \code{p} is a vector of proportions of \code{x} <= each value in \code{x}
#' @param base (numeric) The base to use for \emph{softmax} scaling
#'
#' @note Because this function produces values on a \emph{ratio} scale, all values are shifted such that all values are >= 0.
#'
#' @family Chapter 1 - Calculators
#'
#' @export
# Handle legacy code ...
if (type == "pareto"){ type <- "cumulative" }
ord.i <- base::rank(i, ties.method = "last", na.last = TRUE);
i <- sort(i);
if (any(i < 0)){ i <- i + abs(min(i)) }
# Functions selected by 'type'
cumulative <- \(.i) cumsum(.i)/sum(.i, na.rm = TRUE);
of.max <- \(.i) .i/max(.i, na.rm = TRUE);
of.sum <- \(.i) .i/sum(.i, na.rm = TRUE);
.out <- if (rlang::has_length(type, 1)){
do.call(type, args = list(.i = i)) |> round(decimals)
} else {
purrr::set_names(type) %>% purrr::map(\(k) do.call(k, args = list(.i = i)) |> round(decimals))
}
if (as_density){
if (type == "cumulative"){
.out <- .out * (1 - .out)
} else {
.prop <- cumulative(.out)
.out <- .out * .prop * (1 - .prop)
}
return (.out[ord.i])
}
ratio(x, type = "of.max", as_density = TRUE, base = 10) |> plot()
ratio(x, type = "of.max", as_density = TRUE, base = 10) %>% { plot(x = x, y = ., col = "red") }
#
ratio <- function(i, type = "of.sum", decimals = 2, as_density = FALSE){
#' Ratio Calculator
#'
#' \code{ratio} calculates one of the following ratio types:\cr
#' \enumerate{
#' \item{\code{"of.sum"} (relative to the sum of \code{i})}
#' \item{\code{"of.max"} (relative to maximum value)}
#' \item{\code{"cumulative"} (cumulative total vs. total)}
#' }.\cr Using the related operator \code{\%ratio\%} assumes simple division by the total of \code{i}.
#'
#' @param i (vector) numeric vector
#' @param type (string[]) The types of ratio algorithms to use (see Details): a vector of supported values is supported
#' @param decimals (integer | 2) The number of decimal places to which the output should be rounded
#' @param as_density (logical) \code{TRUE} returns \code{x * p(1 - p)}, where \code{p} is a vector of proportions of \code{x} <= each value in \code{x}
#'
#' @note Because this function produces values on a \emph{ratio} scale, all values are shifted such that all values are >= 0.
#'
#' @family Chapter 1 - Calculators
#'
#' @export
# Handle legacy code ...
if (type == "pareto"){ type <- "cumulative" }
ord.i <- base::rank(i, ties.method = "last", na.last = TRUE);
i <- sort(i);
if (any(i < 0)){ i <- i + abs(min(i)) }
# Functions selected by 'type'
cumulative <- \(.i) cumsum(.i)/sum(.i, na.rm = TRUE);
of.max <- \(.i) .i/max(.i, na.rm = TRUE);
of.sum <- \(.i) .i/sum(.i, na.rm = TRUE);
.out <- if (rlang::has_length(type, 1)){
do.call(type, args = list(.i = i)) |> round(decimals)
} else {
purrr::set_names(type) %>% purrr::map(\(k) do.call(k, args = list(.i = i)) |> round(decimals))
}
if (as_density){
if (type == "cumulative"){
.out <- .out * (1 - .out)
} else {
.prop <- cumulative(.out)
.out <- .out * .prop * (1 - .prop)
}
return (.out[ord.i])
}
ratio(x)
ratio(x, type = "of.max")
ratio(x, type = "cumulative")
ratio(x, type = "pareto")
ratio(x, type = "pareto", as_density = FALSE)
ratio(x, type = "pareto", as_density = FALSE) %>% { plot(x = x, y = ., col = "blue", main = "cumulative") }
ratio(x, type = "pareto", as_density = TRUE) %>% { plot(x = x, y = ., col = "red", main = "cumulative w/ density") }
ratio(x, type = "of.max", as_density = FALSE) %>% { plot(x = x, y = ., col = "green", main = "of.max") }
ratio(x, type = "of.max", as_density = TRUE) %>% { plot(x = x, y = ., col = "orange", main = "of.max w/density") }
library(book.of.utilities)
# ratio ----
x <- sample(-100:100, 30)
ratio(x)
ratio(x, type = "of.max")
ratio(x, type = "cumulative")
ratio(x, type = "pareto")
ratio(x, type = "pareto", as_density = FALSE)
ratio(x, type = "pareto", as_density = FALSE) %>% { plot(x = x, y = ., col = "blue", main = "cumulative") }
ratio(x, type = "pareto", as_density = TRUE) %>% { plot(x = x, y = ., col = "red", main = "cumulative w/ density") }
ratio(x, type = "of.max", as_density = FALSE) %>% { plot(x = x, y = ., col = "green", main = "of.max") }
ratio(x, type = "of.max", as_density = TRUE) %>% { plot(x = x, y = ., col = "orange", main = "of.max w/density") }
rm(x)
#
# Build Site ----
# usethis::use_pkgdown()
pkgdown::build_site(pkg = "pkg", lazy = TRUE, override = list(destination = "../docs"))
